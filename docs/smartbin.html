<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Bin Simulator — สองแคว Workshop</title>
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/p5@1.11.3/lib/p5.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0d1117; color: #e6edf3; font-family: -apple-system, 'Noto Sans Thai', sans-serif; overflow-x: hidden; }

  .layout { display: grid; grid-template-columns: 280px 1fr 300px; gap: 12px; padding: 12px; height: 100vh; }
  @media (max-width: 900px) { .layout { grid-template-columns: 1fr; height: auto; } }

  .panel {
    background: #161b22; border: 1px solid #30363d; border-radius: 12px;
    padding: 16px; overflow-y: auto;
  }
  .panel h2 { color: #58a6ff; font-size: 1rem; margin-bottom: 8px; }
  .panel h3 { color: #8b949e; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; margin: 12px 0 6px; }

  label.ctrl { display: block; font-size: 0.75rem; color: #8b949e; margin: 8px 0 2px; }
  input[type="text"], input[type="range"] { width: 100%; }
  input[type="text"] {
    padding: 8px 10px; background: #0d1117; border: 1px solid #30363d;
    border-radius: 6px; color: #e6edf3; font-size: 0.85rem;
  }
  input[type="range"] { accent-color: #58a6ff; }
  .val { float: right; color: #58a6ff; font-weight: 600; font-size: 0.75rem; }

  .preset-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin: 8px 0; }
  .preset-btn {
    padding: 8px 4px; border: 1px solid #30363d; border-radius: 6px;
    background: #21262d; color: #8b949e; font-size: 0.7rem; cursor: pointer;
    text-align: center; transition: all 0.15s;
  }
  .preset-btn:hover { border-color: #58a6ff; }
  .preset-btn.active { background: #1f3a5f; border-color: #58a6ff; color: #58a6ff; }

  .start-btn {
    width: 100%; padding: 10px; margin-top: 12px; border: none; border-radius: 8px;
    font-size: 0.9rem; font-weight: 700; cursor: pointer;
  }
  .start-btn.off { background: #3fb950; color: #0d1117; }
  .start-btn.on { background: #f87171; color: #0d1117; }

  .status-row { display: flex; align-items: center; gap: 6px; margin: 4px 0; font-size: 0.75rem; }
  .dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .dot.on { background: #3fb950; box-shadow: 0 0 4px #3fb950; }
  .dot.off { background: #f87171; }
  .dot.wait { background: #f0883e; animation: pulse 1.5s infinite; }
  @keyframes pulse { 50% { opacity: 0.4; } }

  .viz-wrap {
    display: flex; justify-content: center; margin-bottom: 12px;
    background: #0d1117; border: 1px solid #30363d; border-radius: 8px;
    padding: 8px 0;
  }
  .viz-wrap canvas { display: block; }

  .chart-wrap { position: relative; height: 220px; margin-bottom: 12px; }

  .feed { max-height: 200px; overflow-y: auto; font-size: 0.7rem; font-family: monospace; }
  .feed-entry { padding: 3px 6px; border-bottom: 1px solid #21262d; display: flex; gap: 8px; }
  .feed-entry .ts { color: #484f58; flex-shrink: 0; }
  .feed-entry .val-col { color: #58a6ff; min-width: 50px; }
  .feed-entry .info { color: #8b949e; }
  .feed-entry.warning { background: rgba(251,191,36,0.08); }
  .feed-entry.warning .val-col { color: #fbbf24; }
  .feed-entry.alert { background: rgba(248,113,113,0.08); }
  .feed-entry.alert .val-col { color: #f87171; }

  .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 8px 0; }
  .stat-card {
    background: #0d1117; border: 1px solid #30363d; border-radius: 8px;
    padding: 10px; text-align: center;
  }
  .stat-card .num { font-size: 1.4rem; font-weight: 700; }
  .stat-card .lbl { font-size: 0.65rem; color: #8b949e; margin-top: 2px; }
  .stat-card.green .num { color: #3fb950; }
  .stat-card.red .num { color: #f87171; }
  .stat-card.yellow .num { color: #fbbf24; }
  .stat-card.blue .num { color: #58a6ff; }

  .header {
    grid-column: 1 / -1; display: flex; align-items: center; gap: 12px;
    padding: 8px 16px; background: #161b22; border: 1px solid #30363d; border-radius: 12px;
  }
  .header h1 {
    font-size: 1.2rem;
    background: linear-gradient(135deg, #58a6ff, #3fb950);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .header .sub { color: #8b949e; font-size: 0.75rem; }
  .header .links { margin-left: auto; font-size: 0.7rem; }
  .header .links a { color: #58a6ff; text-decoration: none; margin-left: 12px; }

  .fill-bar-wrap {
    width: 100%; height: 18px; background: #21262d; border-radius: 9px;
    overflow: hidden; margin: 6px 0; border: 1px solid #30363d;
  }
  .fill-bar {
    height: 100%; border-radius: 9px; transition: width 0.3s, background 0.3s;
  }

  .add-trash-btn {
    width: 100%; padding: 8px; margin-top: 8px; border: 1px solid #30363d; border-radius: 6px;
    background: #21262d; color: #8b949e; font-size: 0.8rem; cursor: pointer;
    transition: all 0.15s;
  }
  .add-trash-btn:hover { border-color: #58a6ff; color: #58a6ff; }
</style>
</head>
<body>

<div class="layout">
  <!-- Header -->
  <div class="header">
    <h1>Smart Bin Simulator</h1>
    <span class="sub">Radar Sensor — ถังขยะอัจฉริยะ</span>
    <div class="links">
      <a href="workshop.html">Workshop</a>
      <a href="floodboy.html">FloodBoy</a>
      <a href="https://github.com/Soul-Brews-Studio/two-rivers-oracle">GitHub</a>
    </div>
  </div>

  <!-- LEFT: Controls -->
  <div class="panel" id="controls-panel">
    <h2>Bin Config</h2>
    <div class="status-row"><div class="dot wait" id="dot-mqtt"></div><span id="status-mqtt">mqtt: connecting...</span></div>

    <label class="ctrl">Sensor ID</label>
    <input type="text" id="sensor-id" value="BIN001" maxlength="20">

    <label class="ctrl">Fill Level <span class="val" id="v-fill">25%</span></label>
    <input type="range" id="r-fill" min="0" max="100" step="1" value="25">

    <label class="ctrl">Bin Capacity <span class="val" id="v-capacity">120 L</span></label>
    <input type="range" id="r-capacity" min="20" max="500" step="10" value="120">

    <label class="ctrl">Sensor Sensitivity <span class="val" id="v-sensitivity">85%</span></label>
    <input type="range" id="r-sensitivity" min="50" max="100" step="1" value="85">

    <label class="ctrl">Fill Rate <span class="val" id="v-rate">2 %/min</span></label>
    <input type="range" id="r-rate" min="0" max="20" step="0.5" value="2">

    <label class="ctrl">Temperature <span class="val" id="v-temp">32 °C</span></label>
    <input type="range" id="r-temp" min="-10" max="60" step="1" value="32">

    <label class="ctrl">Publish Interval <span class="val" id="v-interval">2000 ms</span></label>
    <input type="range" id="r-interval" min="500" max="10000" step="100" value="2000">

    <button class="add-trash-btn" onclick="addTrash()">+ เพิ่มขยะ (Add Trash)</button>

    <h3>Presets</h3>
    <div class="preset-grid" id="preset-grid">
      <button class="preset-btn" data-preset="empty">Empty<br><small>ถังว่าง 0%</small></button>
      <button class="preset-btn" data-preset="half">Half Full<br><small>ครึ่งถัง 50%</small></button>
      <button class="preset-btn" data-preset="almost">Almost Full<br><small>ใกล้เต็ม 85%</small></button>
      <button class="preset-btn" data-preset="overflow">Overflowing<br><small>ล้น 100%+</small></button>
      <button class="preset-btn" data-preset="error">Sensor Error<br><small>เซ็นเซอร์ผิดพลาด</small></button>
    </div>

    <button class="start-btn off" id="btn-start" onclick="togglePublish()">Start Publishing</button>
  </div>

  <!-- CENTER: Visualization + Chart -->
  <div class="panel">
    <h2>Bin Cross-Section</h2>
    <div class="viz-wrap"><div id="viz-container"></div></div>

    <h2>Fill Level</h2>
    <div class="fill-bar-wrap"><div class="fill-bar" id="fill-bar" style="width:25%;background:#3fb950;"></div></div>
    <div style="text-align:center;font-size:0.8rem;color:#8b949e;" id="fill-text">25% — ยังว่างอยู่</div>

    <h2 style="margin-top:12px;">Prediction</h2>
    <div class="chart-wrap"><canvas id="chart"></canvas></div>

    <h3>Live Feed</h3>
    <div class="feed" id="feed"></div>
  </div>

  <!-- RIGHT: Stats -->
  <div class="panel">
    <h2>Bin Statistics</h2>
    <div class="stat-grid">
      <div class="stat-card blue"><div class="num" id="s-fill">25%</div><div class="lbl">Fill Level</div></div>
      <div class="stat-card yellow"><div class="num" id="s-temp">32°C</div><div class="lbl">Temperature</div></div>
      <div class="stat-card green"><div class="num" id="s-predict">—</div><div class="lbl">Full In</div></div>
      <div class="stat-card blue"><div class="num" id="s-collections">0</div><div class="lbl">Collections</div></div>
      <div class="stat-card green"><div class="num" id="s-readings">0</div><div class="lbl">Readings</div></div>
      <div class="stat-card red"><div class="num" id="s-alerts">0</div><div class="lbl">Alerts Sent</div></div>
    </div>

    <h3>Prediction Info</h3>
    <div style="font-size:0.7rem;color:#8b949e;margin-bottom:8px;">
      <div>Fill rate: <span style="color:#58a6ff" id="info-rate">2 %/min</span></div>
      <div>Predicted full: <span style="color:#fbbf24" id="info-full-time">—</span></div>
      <div>Last emptied: <span style="color:#3fb950" id="info-emptied">—</span></div>
      <div>Status: <span style="color:#3fb950" id="info-status">Normal</span></div>
    </div>

    <h3>Alert Log</h3>
    <div class="feed" id="alert-feed" style="max-height:250px;"></div>
  </div>
</div>

<script>
// ===== CONSTANTS =====
const MQTT_BROKER = 'wss://dustboy-wss-bridge.laris.workers.dev/mqtt';
const MAX_CHART_POINTS = 60;
const MAX_FEED = 30;

// ===== STATE =====
let mqttClient = null;
let publishing = false;
let pubTimer = null;
let sensorError = false;
let fillHistory = [];
let stats = { readings: 0, collections: 0, alerts: 0 };
let trashParticles = [];
let radarPulses = [];
let lastEmptied = null;

// ===== SLIDER BINDINGS =====
const sliders = [
  ['r-fill', 'v-fill', v => v + '%', 0],
  ['r-capacity', 'v-capacity', v => v + ' L', 0],
  ['r-sensitivity', 'v-sensitivity', v => v + '%', 0],
  ['r-rate', 'v-rate', v => v + ' %/min', 1],
  ['r-temp', 'v-temp', v => v + ' °C', 0],
  ['r-interval', 'v-interval', v => v + ' ms', 0],
];
for (const [rid, vid, fmt, dec] of sliders) {
  const r = document.getElementById(rid);
  const v = document.getElementById(vid);
  r.addEventListener('input', () => { v.textContent = fmt(parseFloat(r.value).toFixed(dec)); });
}

// ===== ADD TRASH =====
window.addTrash = function() {
  const r = document.getElementById('r-fill');
  let fill = parseFloat(r.value);
  fill = Math.min(105, fill + 5 + Math.random() * 10);
  r.value = fill;
  document.getElementById('v-fill').textContent = Math.round(fill) + '%';
  // Spawn particles
  for (let i = 0; i < 5; i++) {
    trashParticles.push({
      x: 120 + Math.random() * 110,
      y: 30 + Math.random() * 20,
      vy: 1 + Math.random() * 2,
      size: 4 + Math.random() * 6,
      color: ['#8b949e','#6e7681','#484f58','#a0a0a0'][Math.floor(Math.random()*4)],
      life: 60,
    });
  }
};

// ===== PRESET BUTTONS =====
document.getElementById('preset-grid').addEventListener('click', e => {
  const btn = e.target.closest('.preset-btn');
  if (!btn) return;
  document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  const preset = btn.dataset.preset;
  sensorError = false;

  switch (preset) {
    case 'empty':
      document.getElementById('r-fill').value = 0;
      document.getElementById('v-fill').textContent = '0%';
      break;
    case 'half':
      document.getElementById('r-fill').value = 50;
      document.getElementById('v-fill').textContent = '50%';
      break;
    case 'almost':
      document.getElementById('r-fill').value = 85;
      document.getElementById('v-fill').textContent = '85%';
      break;
    case 'overflow':
      document.getElementById('r-fill').value = 105;
      document.getElementById('v-fill').textContent = '105%';
      break;
    case 'error':
      sensorError = true;
      break;
  }
});

// ===== CHART SETUP =====
const ctx = document.getElementById('chart').getContext('2d');
const chart = new Chart(ctx, {
  type: 'line',
  data: {
    labels: [],
    datasets: [
      {
        label: 'Fill Level (%)',
        data: [], borderColor: 'rgba(88,166,255,0.8)', backgroundColor: 'rgba(88,166,255,0.1)',
        fill: true, pointRadius: 2, borderWidth: 1.5, tension: 0.3,
      },
      {
        label: 'Prediction',
        data: [], borderColor: 'rgba(251,191,36,0.6)', backgroundColor: 'transparent',
        pointRadius: 0, borderWidth: 2, borderDash: [5,3], tension: 0.3,
      },
    ],
  },
  options: {
    responsive: true, maintainAspectRatio: false,
    animation: { duration: 200 },
    scales: {
      x: { display: false },
      y: {
        min: 0, max: 110,
        grid: { color: '#21262d' }, ticks: { color: '#8b949e', font: { size: 10 }, callback: v => v + '%' },
      },
    },
    plugins: {
      legend: { labels: { color: '#8b949e', font: { size: 10 }, boxWidth: 12 } },
    },
  },
});

// ===== P5.JS BIN VISUALIZATION =====
const vizSketch = new p5(function(p) {
  const W = 400, H = 420;

  p.setup = function() {
    p.createCanvas(W, H);
    p.frameRate(30);
  };

  p.draw = function() {
    p.clear();
    p.background(13, 17, 23);

    const fillLevel = parseFloat(document.getElementById('r-fill').value);
    const time = p.millis() / 1000;

    const binX = 100, binY = 60, binW = 200, binH = 300;
    const innerX = binX + 8, innerY = binY + 8;
    const innerW = binW - 16, innerH = binH - 16;

    // ── Bin outer shell ──
    p.noStroke();
    p.fill(55, 65, 81);
    p.rect(binX, binY, binW, binH, 6);
    // Inner cavity
    p.fill(21, 26, 33);
    p.rect(innerX, innerY, innerW, innerH, 4);

    // ── Trash fill ──
    const fillFrac = Math.min(fillLevel / 100, 1.05);
    const trashH = fillFrac * innerH;
    const trashY = innerY + innerH - trashH;

    if (trashH > 0) {
      // Trash color by level
      let trashR, trashG, trashB;
      if (fillLevel < 50) { trashR = 63; trashG = 185; trashB = 80; }
      else if (fillLevel < 80) { trashR = 251; trashG = 191; trashB = 36; }
      else { trashR = 248; trashG = 113; trashB = 113; }

      p.fill(trashR, trashG, trashB, 120);
      p.rect(innerX, trashY, innerW, trashH, 0, 0, 4, 4);

      // Trash surface texture
      p.fill(trashR, trashG, trashB, 60);
      for (let i = 0; i < 15; i++) {
        const tx = innerX + 10 + (i * 37 + time * 5) % (innerW - 20);
        const ty = trashY + 5 + Math.sin(i * 2.1 + time) * 3;
        p.ellipse(tx, ty, 8 + Math.sin(i + time) * 3, 5);
      }

      // Trash items inside
      p.fill(trashR, trashG, trashB, 40);
      for (let i = 0; i < 20; i++) {
        const ix = innerX + 15 + (i * 29) % (innerW - 30);
        const iy = trashY + 20 + (i * 43) % Math.max(trashH - 30, 1);
        if (iy < innerY + innerH - 5) {
          p.rect(ix, iy, 6 + (i % 4) * 2, 4 + (i % 3) * 2, 2);
        }
      }
    }

    // ── Radar sensor at top ──
    const sensorX = binX + binW / 2;
    const sensorY = binY - 15;
    p.fill(107, 114, 128);
    p.rect(sensorX - 20, sensorY, 40, 20, 4);
    p.fill(55, 65, 81);
    p.rect(sensorX - 14, sensorY + 4, 28, 12, 3);
    // Lens
    p.fill(17, 24, 39);
    p.circle(sensorX, sensorY + 10, 10);

    // LED on sensor
    if (sensorError) {
      p.fill(239, 68, 68, 180 + Math.sin(time * 6) * 75);
    } else {
      p.fill(63, 185, 80, 180 + Math.sin(time * 2) * 50);
    }
    p.circle(sensorX + 12, sensorY + 5, 4);

    // ── Radar pulses ──
    if (!sensorError) {
      for (let i = 0; i < 3; i++) {
        const pt = (time * 1.2 + i * 1.0) % 3;
        const pulseY = sensorY + 20 + pt * (trashH > 0 ? (innerH - trashH) : innerH) * 0.33;
        const alpha = Math.max(0, 1 - pt / 3) * 80;
        const pw = 20 + pt * 30;
        if (alpha > 0 && pulseY < innerY + innerH) {
          p.noFill();
          p.stroke(88, 166, 255, alpha);
          p.strokeWeight(1.5);
          p.arc(sensorX, sensorY + 20, pw, pulseY - sensorY, 0.3, Math.PI - 0.3);
          p.noStroke();
        }
      }
    }

    // ── Radar beam (dashed line to surface) ──
    const targetY = trashH > 0 ? trashY : innerY + innerH;
    p.stroke(88, 166, 255, 100);
    p.strokeWeight(1);
    p.drawingContext.setLineDash([3, 3]);
    p.line(sensorX, sensorY + 20, sensorX, targetY);
    p.drawingContext.setLineDash([]);
    p.noStroke();

    // ── Distance label ──
    const distPct = Math.round(fillLevel);
    p.fill(sensorError ? 248 : 88, sensorError ? 113 : 166, sensorError ? 113 : 255);
    p.textAlign(p.CENTER, p.CENTER);
    p.textSize(16);
    p.textStyle(p.BOLD);
    if (sensorError) {
      p.text('ERROR', sensorX, innerY + innerH / 2);
    } else {
      p.text(distPct + '%', sensorX, innerY + innerH / 2 - 10);
      p.textSize(11);
      p.textStyle(p.NORMAL);
      p.fill(139, 148, 158);
      const cap = parseFloat(document.getElementById('r-capacity').value);
      p.text(Math.round(cap * fillLevel / 100) + ' / ' + cap + ' L', sensorX, innerY + innerH / 2 + 10);
    }

    // ── Falling trash particles ──
    for (let i = trashParticles.length - 1; i >= 0; i--) {
      const tp = trashParticles[i];
      tp.y += tp.vy;
      tp.life--;
      if (tp.y > trashY && trashH > 0) tp.life = 0;
      if (tp.y > innerY + innerH) tp.life = 0;
      if (tp.life <= 0) { trashParticles.splice(i, 1); continue; }
      p.fill(tp.color);
      p.rect(tp.x, tp.y, tp.size, tp.size, 2);
    }

    // ── Bin label ──
    p.fill(139, 148, 158);
    p.textAlign(p.CENTER, p.TOP);
    p.textSize(11);
    p.textStyle(p.NORMAL);
    p.text('ถังขยะอัจฉริยะ', binX + binW / 2, binY + binH + 8);

    // ── Warning overlay ──
    if (fillLevel >= 85) {
      p.fill(248, 113, 113, 30 + Math.sin(time * 3) * 20);
      p.rect(innerX, innerY, innerW, innerH, 4);
      p.fill(248, 113, 113);
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(12);
      p.textStyle(p.BOLD);
      if (fillLevel >= 100) {
        p.text('OVERFLOWING', sensorX, binY + binH + 25);
      } else {
        p.text('ALMOST FULL', sensorX, binY + binH + 25);
      }
      p.textStyle(p.NORMAL);
    }
  };
}, document.getElementById('viz-container'));

// ===== GENERATE READING =====
function generateReading() {
  let fill = parseFloat(document.getElementById('r-fill').value);
  const rate = parseFloat(document.getElementById('r-rate').value);
  const sensitivity = parseFloat(document.getElementById('r-sensitivity').value);
  const temp = parseFloat(document.getElementById('r-temp').value);
  const interval = parseFloat(document.getElementById('r-interval').value);

  if (sensorError) {
    return { fill: -1, temp: temp, error: true };
  }

  // Auto-increase fill based on rate
  if (publishing && rate > 0) {
    const ratePerTick = rate * (interval / 60000);
    fill = Math.min(105, fill + ratePerTick);
    document.getElementById('r-fill').value = fill;
    document.getElementById('v-fill').textContent = Math.round(fill) + '%';
  }

  // Noise based on sensitivity (lower sensitivity = more noise)
  const noise = (100 - sensitivity) / 100 * 5;
  const measured = fill + (Math.random() - 0.5) * noise;

  return { fill: +Math.max(0, measured).toFixed(1), temp: +(temp + (Math.random() - 0.5) * 2).toFixed(1), error: false };
}

// ===== PREDICTION =====
function predictFull(currentFill, rate) {
  if (rate <= 0 || currentFill >= 100) return null;
  const remaining = 100 - currentFill;
  const minutes = remaining / rate;
  if (minutes > 1440) return null; // > 24h
  if (minutes < 60) return Math.round(minutes) + ' min';
  return (minutes / 60).toFixed(1) + ' hr';
}

// ===== UPDATE FILL BAR =====
function updateFillBar(fill) {
  const bar = document.getElementById('fill-bar');
  const text = document.getElementById('fill-text');
  const pct = Math.min(100, Math.max(0, fill));
  bar.style.width = pct + '%';

  if (fill < 50) {
    bar.style.background = '#3fb950';
    text.textContent = Math.round(fill) + '% — ยังว่างอยู่';
  } else if (fill < 80) {
    bar.style.background = '#fbbf24';
    text.textContent = Math.round(fill) + '% — กำลังเพิ่มขึ้น';
  } else if (fill < 100) {
    bar.style.background = '#f87171';
    text.textContent = Math.round(fill) + '% — ใกล้เต็มแล้ว!';
  } else {
    bar.style.background = '#f87171';
    text.textContent = Math.round(fill) + '% — ล้นแล้ว! ต้องเก็บด่วน';
  }
}

// ===== PUBLISH =====
function publishReading() {
  const sensorId = document.getElementById('sensor-id').value || 'BIN001';
  const reading = generateReading();
  const ts = Date.now();
  const now = new Date(ts);
  const timeStr = now.toLocaleTimeString('th-TH', { hour12: false });
  const rate = parseFloat(document.getElementById('r-rate').value);

  stats.readings++;

  const prediction = predictFull(reading.fill, rate);

  const payload = {
    fill_level: reading.fill,
    temperature: reading.temp,
    predicted_full_time: prediction || 'N/A',
    capacity: parseFloat(document.getElementById('r-capacity').value),
    sensor_error: reading.error,
    timestamp: ts,
  };

  if (mqttClient?.connected) {
    mqttClient.publish('SmartBin/' + sensorId + '/status', JSON.stringify(payload));
  }

  // Check alerts
  let alertType = null;
  if (reading.error) {
    alertType = 'error';
    stats.alerts++;
    addAlertEntry(timeStr, 'Sensor Error — เซ็นเซอร์ผิดพลาด');
  } else if (reading.fill >= 100) {
    alertType = 'overflow';
    stats.alerts++;
    addAlertEntry(timeStr, 'Overflowing — ถังล้น! ' + reading.fill + '%');
  } else if (reading.fill >= 85) {
    alertType = 'warning';
    if (stats.readings % 5 === 0) {
      stats.alerts++;
      addAlertEntry(timeStr, 'Almost Full — ใกล้เต็ม ' + reading.fill + '%');
    }
  }

  // Auto-collection if overflowing
  if (reading.fill >= 105 && !reading.error) {
    stats.collections++;
    document.getElementById('r-fill').value = 5;
    document.getElementById('v-fill').textContent = '5%';
    lastEmptied = timeStr;
    document.getElementById('info-emptied').textContent = timeStr;
    addAlertEntry(timeStr, 'Collection — เก็บขยะแล้ว');
  }

  // Update UI
  updateFillBar(reading.error ? 0 : reading.fill);

  // Update chart
  chart.data.labels.push(timeStr);
  chart.data.datasets[0].data.push(reading.error ? null : reading.fill);
  // Prediction line
  if (!reading.error && rate > 0 && reading.fill < 100) {
    chart.data.datasets[1].data.push(Math.min(100, reading.fill + rate * 2));
  } else {
    chart.data.datasets[1].data.push(null);
  }
  if (chart.data.labels.length > MAX_CHART_POINTS) {
    chart.data.labels.shift();
    chart.data.datasets.forEach(d => d.data.shift());
  }
  chart.update('none');

  // Feed
  const cls = alertType === 'error' ? 'alert' : alertType === 'overflow' ? 'alert' : alertType === 'warning' ? 'warning' : '';
  addFeedEntry(timeStr, reading, cls, prediction);
  updateStats(reading, prediction);
}

// ===== FEED =====
function addFeedEntry(time, reading, cls, prediction) {
  const feed = document.getElementById('feed');
  const el = document.createElement('div');
  el.className = 'feed-entry ' + cls;
  const fillStr = reading.error ? 'ERR' : reading.fill.toFixed(1) + '%';
  const predStr = prediction ? ' → full in ' + prediction : '';
  el.innerHTML = '<span class="ts">' + time + '</span><span class="val-col">' + fillStr + '</span><span class="info">' + reading.temp + '°C' + predStr + '</span>';
  feed.prepend(el);
  while (feed.children.length > MAX_FEED) feed.lastChild.remove();
}

function addAlertEntry(time, msg) {
  const feed = document.getElementById('alert-feed');
  const el = document.createElement('div');
  el.className = 'feed-entry alert';
  el.innerHTML = '<span class="ts">' + time + '</span><span class="val-col" style="color:#f87171">ALERT</span><span class="info">' + msg + '</span>';
  feed.prepend(el);
  while (feed.children.length > MAX_FEED) feed.lastChild.remove();
}

function updateStats(reading, prediction) {
  document.getElementById('s-fill').textContent = reading.error ? 'ERR' : Math.round(reading.fill) + '%';
  document.getElementById('s-temp').textContent = reading.temp + '°C';
  document.getElementById('s-predict').textContent = prediction || '—';
  document.getElementById('s-collections').textContent = stats.collections;
  document.getElementById('s-readings').textContent = stats.readings;
  document.getElementById('s-alerts').textContent = stats.alerts;

  const rate = parseFloat(document.getElementById('r-rate').value);
  document.getElementById('info-rate').textContent = rate + ' %/min';
  document.getElementById('info-full-time').textContent = prediction || '—';
  document.getElementById('info-status').textContent = reading.error ? 'Sensor Error' : reading.fill >= 85 ? 'Warning' : 'Normal';
  document.getElementById('info-status').style.color = reading.error ? '#f87171' : reading.fill >= 85 ? '#fbbf24' : '#3fb950';
}

// ===== MQTT =====
function initMQTT() {
  mqttClient = mqtt.connect(MQTT_BROKER);
  mqttClient.on('connect', () => {
    document.getElementById('dot-mqtt').className = 'dot on';
    document.getElementById('status-mqtt').textContent = 'mqtt: connected';
  });
  mqttClient.on('offline', () => {
    document.getElementById('dot-mqtt').className = 'dot off';
    document.getElementById('status-mqtt').textContent = 'mqtt: offline';
  });
}

// ===== START / STOP =====
window.togglePublish = function() {
  const btn = document.getElementById('btn-start');
  if (publishing) {
    publishing = false;
    clearInterval(pubTimer);
    btn.textContent = 'Start Publishing';
    btn.className = 'start-btn off';
  } else {
    publishing = true;
    const interval = parseInt(document.getElementById('r-interval').value);
    pubTimer = setInterval(publishReading, interval);
    btn.textContent = 'Stop Publishing';
    btn.className = 'start-btn on';
    stats = { readings: 0, collections: 0, alerts: 0 };
    publishReading();
  }
};

// ===== URL PARAMS =====
const params = new URLSearchParams(window.location.search);
if (params.get('id')) document.getElementById('sensor-id').value = params.get('id');
if (params.get('auto')) setTimeout(() => togglePublish(), 500);

// ===== INIT =====
initMQTT();
</script>
</body>
</html>