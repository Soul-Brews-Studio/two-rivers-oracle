<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FloodBoy Webapp - JIBCHAIN L1</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js and Date Adapter -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6', // Blue for water
                        secondary: '#10B981', // Green for battery
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }

        .glass-card {
            background: white;
            border-radius: 1.5rem;
            box-shadow: 0 4px 20px -5px rgba(0, 0, 0, 0.05), 0 8px 10px -5px rgba(0, 0, 0, 0.01);
        }

        .loader {
            border-top-color: #3b82f6;
            -webkit-animation: spinner 1.5s linear infinite;
            animation: spinner 1.5s linear infinite;
        }

        @keyframes spinner {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .btn-toggle {
            transition: all 0.2s ease-in-out;
        }
    </style>
</head>

<body class="p-4 md:p-8 min-h-screen">

    <div id="loadingOverlay"
        class="fixed inset-0 bg-white/80 z-50 flex flex-col items-center justify-center backdrop-blur-sm">
        <div class="w-16 h-16 border-4 border-gray-200 rounded-full loader mb-4"></div>
        <h2 class="text-xl font-semibold text-gray-700 font-inter">Loading FloodBoy Data...</h2>
        <p id="loadingStatusText" class="text-gray-500 mt-2">Connecting to JIBCHAIN L1 Smart Contracts</p>
    </div>

    <!-- Store Selector & Header Controls -->
    <div class="max-w-6xl mx-auto mb-6 flex justify-between items-end">
        <div>
            <h1 class="text-3xl font-bold flex items-center gap-3 text-gray-800">
                <i class="fa-solid fa-water text-primary"></i>
                FloodBoy Webapp
            </h1>
            <p class="text-gray-500 text-sm mt-1">IoT-Powered Blockchain Monitoring</p>
        </div>
        <div>
            <label class="text-sm text-gray-500 font-medium block mb-1">Select Active Sensor Store</label>
            <select id="storeSelector"
                class="bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-primary focus:border-primary block w-full p-2.5 shadow-sm">
                <option value="0x0994Bc66b2863f8D58C8185b1ed6147895632812" selected>FloodBoy016</option>
                <option value="0xCd3Ec17ddFDa24f8F97131fa0FDf20e7cbd1A8Bb">FloodBoy001</option>
            </select>
        </div>
    </div>

    <div class="max-w-6xl mx-auto glass-card overflow-hidden transition-all duration-300 mb-8">

        <!-- Header Section -->
        <div
            class="px-8 py-6 border-b border-gray-100 flex flex-col md:flex-row justify-between items-start md:items-center gap-4 relative">
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-primary to-secondary"></div>
            <div>
                <div
                    class="inline-flex items-center gap-2 px-3 py-1 rounded-full bg-green-50 text-green-700 text-xs font-semibold mb-3 border border-green-100">
                    <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                    Live Data Active
                </div>
                <h2 id="storeNickname" class="text-3xl font-bold text-gray-900 tracking-tight">Loading...</h2>
                <h3 id="storeDesc" class="text-lg text-gray-500 mt-1 font-medium">Fetching details...</h3>
            </div>

            <div class="bg-gray-50 p-4 rounded-xl border border-gray-100 min-w-[280px]">
                <div class="flex justify-between text-sm mb-2">
                    <span class="text-gray-500">Current Block</span>
                    <span id="currentBlock" class="font-mono font-medium text-gray-900">-</span>
                </div>
                <div class="flex justify-between text-sm mb-2">
                    <span class="text-gray-500">Last Updated</span>
                    <span id="lastUpdated" class="font-medium text-gray-900">-</span>
                </div>
                <div class="flex justify-between text-sm">
                    <span class="text-gray-500">Store Contract</span>
                    <a id="storeLink" href="#" target="_blank"
                        class="font-mono font-medium text-primary hover:underline flex items-center gap-1 group">
                        <span id="storeAddrTrunc">-</span>
                        <i
                            class="fa-solid fa-external-link-alt text-[10px] group-hover:translate-x-0.5 group-hover:-translate-y-0.5 transition-transform"></i>
                    </a>
                </div>
            </div>
        </div>

        <!-- Chart Section -->
        <div class="px-8 py-6 border-b border-gray-100">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4">
                <h3 class="text-xl font-bold text-gray-800" id="chartTitle">Water Depth Over Time</h3>

                <div class="flex bg-gray-100 rounded-lg p-1">
                    <button id="toggleWater"
                        class="btn-toggle px-4 py-2 rounded-md text-sm font-semibold shadow-sm bg-white text-primary ring-1 ring-gray-200">
                        <i class="fa-solid fa-water mr-1"></i> Water Depth
                    </button>
                    <button id="toggleBattery"
                        class="btn-toggle px-4 py-2 rounded-md text-sm font-semibold text-gray-500 hover:text-gray-700">
                        <i class="fa-solid fa-battery-half mr-1"></i> Battery Voltage
                    </button>
                </div>
            </div>

            <div id="alertContainer"
                class="hidden mb-4 p-4 rounded-lg bg-yellow-50 border border-yellow-200 text-yellow-800 flex items-center gap-3">
                <i class="fa-solid fa-circle-exclamation text-yellow-600"></i>
                <span id="alertMessage">No historical data available.</span>
            </div>

            <div class="relative w-full h-[400px]">
                <canvas id="mainChart"></canvas>
            </div>
        </div>

        <!-- Data Table Section -->
        <div class="px-8 py-6">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Latest Sensor Data</h3>
            <div class="overflow-x-auto rounded-xl border border-gray-200 shadow-sm">
                <table class="w-full text-left border-collapse">
                    <thead>
                        <tr class="bg-gray-50 text-gray-600 text-sm border-b border-gray-200">
                            <th class="px-6 py-4 font-semibold w-1/4">Metric</th>
                            <th class="px-6 py-4 font-semibold">Current</th>
                            <th class="px-6 py-4 font-semibold">Min (24h)</th>
                            <th class="px-6 py-4 font-semibold">Max (24h)</th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody" class="divide-y divide-gray-100 bg-white">
                        <tr>
                            <td colspan="4" class="px-6 py-8 text-center text-gray-500">Loading data metrics...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Footer -->
        <div class="px-8 py-6 bg-slate-50 border-t border-gray-100 text-sm text-gray-500 grid md:grid-cols-2 gap-4">
            <div>
                <p class="mb-1"><span class="font-medium">Last Updated:</span> <span id="footerLastSync">-</span></p>
                <p><span class="font-medium">Sensor Count:</span> <span id="footerSensorCount">-</span> authorized</p>
            </div>
            <div class="md:text-right">
                <p class="mb-1">
                    <span class="font-medium">Store Owner:</span>
                    <a id="ownerLink" href="#" target="_blank" class="font-mono text-primary hover:underline">-</a>
                </p>
                <p>
                    <span class="font-medium">Deployed Block:</span>
                    <a id="blockLink" href="#" target="_blank" class="font-mono text-primary hover:underline">-</a>
                </p>
            </div>
        </div>
    </div>

    <!-- Application Logic -->
    <script type="module">
        import { createPublicClient, http } from 'https://esm.sh/viem@2.8.0';

        // Viem Configurations
        const jibchain = {
            id: 8899,
            name: 'JIBCHAIN L1',
            rpcUrls: {
                default: { http: ['https://rpc-l1.jibchain.net'] }
            }
        };

        const client = createPublicClient({
            chain: jibchain,
            transport: http()
        });

        const FACTORY_ADDRESS = '0x63bB41b79b5aAc6e98C7b35Dcb0fE941b85Ba5Bb';
        const UNIVERSAL_SIGNER = '0xcB0e58b011924e049ce4b4D62298Edf43dFF0BDd';

        const factoryABI = [{ "name": "getStoreInfo", "inputs": [{ "name": "store", "type": "address" }], "outputs": [{ "name": "nickname", "type": "string" }, { "name": "owner", "type": "address" }, { "name": "authorizedSensorCount", "type": "uint256" }, { "name": "deployedBlock", "type": "uint128" }, { "name": "description", "type": "string" }], "stateMutability": "view", "type": "function" }];

        const storeABI = [
            { "name": "getAllFields", "outputs": [{ "components": [{ "name": "name", "type": "string" }, { "name": "unit", "type": "string" }, { "name": "dtype", "type": "string" }], "type": "tuple[]" }], "stateMutability": "view", "type": "function" },
            { "name": "getLatestRecord", "inputs": [{ "name": "sensor", "type": "address" }], "outputs": [{ "name": "", "type": "uint256" }, { "name": "", "type": "int256[]" }], "stateMutability": "view", "type": "function" },
            { "anonymous": false, "inputs": [{ "indexed": true, "name": "sensor", "type": "address" }, { "indexed": false, "name": "timestamp", "type": "uint256" }, { "indexed": false, "name": "values", "type": "int256[]" }], "name": "RecordStored", "type": "event" }
        ];

        let currentChart = null;
        let activeDatasetType = 'waterDepth';
        let cachedEvents = [];
        let fieldConfigs = [];

        const loadingOverlay = document.getElementById('loadingOverlay');
        const storeSelector = document.getElementById('storeSelector');

        // Critical Unit Conversion Math
        function processValue(value, unit) {
            const baseUnit = unit.replace(/ x\d+/, '');
            if (unit.includes('x10000')) return (Number(value) / 10000).toFixed(4) + ' ' + baseUnit;
            if (unit.includes('x1000')) return (Number(value) / 1000).toFixed(3) + ' ' + baseUnit;
            if (unit.includes('x100')) return (Number(value) / 100).toFixed(3) + ' ' + baseUnit;
            return value + ' ' + baseUnit;
        }

        function processRawValue(value, unit) {
            if (unit.includes('x10000')) return Number(value) / 10000;
            if (unit.includes('x1000')) return Number(value) / 1000;
            if (unit.includes('x100')) return Number(value) / 100;
            return Number(value);
        }

        // Smart water level filtering â€” removes sensor failures, impossible values, and outliers
        function filterWaterLevelEvents(events) {
            const waterIdx = fieldConfigs.findIndex(f => f.name.toLowerCase() === 'water_depth');
            if (waterIdx < 0) return events;

            return events.filter((evt, i, arr) => {
                const raw = Number(evt.args.values[waterIdx]);
                const unit = fieldConfigs[waterIdx].unit;
                const depth = unit.includes('x1000') ? raw / 1000 : unit.includes('x100') ? raw / 100 : raw;

                // Filter zeros (sensor failures) and out-of-range
                if (depth === 0 || depth < 0 || depth > 20) return false;

                // Isolated spike detection
                if (i > 0 && i < arr.length - 1) {
                    const prevRaw = Number(arr[i-1].args.values[waterIdx]);
                    const nextRaw = Number(arr[i+1].args.values[waterIdx]);
                    const returnToBaseline = Math.abs(prevRaw - nextRaw);
                    const avgSurr = (prevRaw + nextRaw) / 2;
                    const deviation = Math.abs(raw - avgSurr);
                    if (returnToBaseline < 500 && deviation > 1000) return false;
                    if (returnToBaseline < 1000 && deviation > 2500) return false;
                }

                // Rate-of-change with time gap awareness
                if (i > 0) {
                    const prev = arr[i-1];
                    const timeDiff = Math.abs(Number(evt.args.timestamp) - Number(prev.args.timestamp)) / 60;
                    const prevRaw = Number(prev.args.values[waterIdx]);
                    const change = Math.abs(raw - prevRaw);
                    const maxChange = Math.max(5000, (timeDiff / 15) * 5000);
                    if (change > maxChange) return false;
                }

                return true;
            });
        }

        function formatFieldName(fieldName, sampleCount = 0) {
            let name = fieldName.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');

            if (fieldName.toLowerCase() === 'water_depth' && sampleCount > 0) {
                name = `${name} (${sampleCount} samples)`;
            }
            return name;
        }

        function truncateAddr(addr) {
            if (!addr) return '';
            return `${addr.substring(0, 10)}...${addr.substring(addr.length - 6)}`;
        }

        async function initApp() {
            try {
                const loadingStatus = document.getElementById('loadingStatusText');
                if (loadingStatus) loadingStatus.textContent = "Fetching Store Data...";

                document.getElementById('dataTableBody').innerHTML = '<tr><td colspan="4" class="px-6 py-8 text-center text-gray-500">Loading data metrics...</td></tr>';
                if (currentChart) { currentChart.destroy(); currentChart = null; }

                const storeAddr = storeSelector.value;
                document.getElementById('storeLink').href = `https://exp-l1.jibchain.net/address/${storeAddr}`;
                document.getElementById('storeAddrTrunc').textContent = truncateAddr(storeAddr);

                const currentBlockNum = await client.getBlockNumber();
                document.getElementById('currentBlock').textContent = Number(currentBlockNum).toLocaleString();

                const [nickname, owner, sensorCount, deployedBlock, description] = await client.readContract({
                    address: FACTORY_ADDRESS,
                    abi: factoryABI,
                    functionName: 'getStoreInfo',
                    args: [storeAddr]
                });

                document.getElementById('storeNickname').textContent = nickname;
                document.getElementById('storeDesc').textContent = description;
                document.getElementById('footerSensorCount').textContent = Number(sensorCount);
                document.getElementById('ownerLink').textContent = truncateAddr(owner);
                document.getElementById('ownerLink').href = `https://exp-l1.jibchain.net/address/${owner}`;
                document.getElementById('blockLink').textContent = `#${Number(deployedBlock).toLocaleString()}`;
                document.getElementById('blockLink').href = `https://exp-l1.jibchain.net/block/${deployedBlock}`;

                fieldConfigs = await client.readContract({
                    address: storeAddr,
                    abi: storeABI,
                    functionName: 'getAllFields'
                });

                const [lastTimestamp, currentRecordVals] = await client.readContract({
                    address: storeAddr,
                    abi: storeABI,
                    functionName: 'getLatestRecord',
                    args: [UNIVERSAL_SIGNER]
                });

                const dateSync = new Date(Number(lastTimestamp) * 1000);
                const timeStr = dateSync.toLocaleString('en-US', { timeStyle: 'medium', dateStyle: 'short' });
                document.getElementById('lastUpdated').textContent = timeStr;
                document.getElementById('footerLastSync').textContent = timeStr;

                if (loadingStatus) loadingStatus.textContent = "Fetching Store Data...";

                // Hide overlay early!
                loadingOverlay.classList.add('hidden');

                // Show a loading banner inside the chart container instead of blocking the whole page
                document.getElementById('alertMessage').innerHTML = `<i class="fa-solid fa-circle-notch fa-spin mr-2"></i> Loading historical data to build charts...`;
                document.getElementById('alertContainer').classList.remove('hidden');
                document.getElementById('alertContainer').className = "mb-4 p-4 rounded-lg bg-blue-50 border border-blue-200 text-blue-800 flex items-center";


                const fromBlock = currentBlockNum - 28800n; // Approx 24 hours
                cachedEvents = [];
                const CHUNK_SIZE = 1999n;
                const totalChunks = Math.ceil(28800 / Number(CHUNK_SIZE));
                let fetchCount = 0;

                for (let start = fromBlock; start <= currentBlockNum; start += CHUNK_SIZE) {
                    let end = start + CHUNK_SIZE - 1n;
                    if (end > currentBlockNum) end = currentBlockNum;

                    fetchCount++;
                    document.getElementById('alertMessage').innerHTML = `<i class="fa-solid fa-circle-notch fa-spin mr-2"></i> Fetching historical block chunks (${fetchCount}/${totalChunks})...`;

                    try {
                        const chunkEvents = await client.getContractEvents({
                            address: storeAddr,
                            abi: storeABI,
                            eventName: 'RecordStored',
                            fromBlock: start,
                            toBlock: end,
                            args: { sensor: UNIVERSAL_SIGNER }
                        });

                        if (chunkEvents.length > 0) {
                            cachedEvents.push(...chunkEvents);
                            // Sort and Update UI dynamically as chunks arrive
                            cachedEvents.sort((a, b) => Number(a.args.timestamp) - Number(b.args.timestamp));
                            updateTableWithHistory(currentRecordVals);
                            updateChart();
                        }
                    } catch (e) {
                        console.warn(`Failed to fetch events for blocks ${start}-${end}:`, e);
                    }
                }

                document.getElementById('alertContainer').classList.add('hidden');
                document.getElementById('alertContainer').className = "hidden mb-4 p-4 rounded-lg bg-yellow-50 border border-yellow-200 text-yellow-800 flex items-center gap-3";

            } catch (err) {
                console.error("Initialization Failed:", err);
                loadingOverlay.classList.add('hidden');
                document.getElementById('dataTableBody').innerHTML = `<tr><td colspan="4" class="px-6 py-8 text-center text-red-500 font-medium">Failed to load data: ${err.message}</td></tr>`;
                document.getElementById('alertMessage').textContent = `Loading failed: ${err.message}`;
                document.getElementById('alertContainer').classList.remove('hidden');
            }
        }

        function updateTableWithHistory(currentRecordVals) {
            const minMaxData = fieldConfigs.map(() => ({ min: Infinity, max: -Infinity }));
            const filteredForTable = filterWaterLevelEvents(cachedEvents);
            filteredForTable.forEach(evt => {
                evt.args.values.forEach((v, idx) => {
                    const num = Number(v);
                    if (num < minMaxData[idx].min) minMaxData[idx].min = num;
                    if (num > minMaxData[idx].max) minMaxData[idx].max = num;
                });
            });

            const tbody = document.getElementById('dataTableBody');
            tbody.innerHTML = '';
            let parity = false;
            const sampleCount = filteredForTable.length;

            fieldConfigs.forEach((field, index) => {
                if (field.name.includes('min') || field.name.includes('max')) return;

                const fName = formatFieldName(field.name, field.name === 'water_depth' ? sampleCount : 0);

                const curVal = currentRecordVals[index] !== undefined ? processValue(currentRecordVals[index], field.unit) : 'N/A';
                const minVal = minMaxData[index].min !== Infinity ? processValue(minMaxData[index].min, field.unit) : 'N/A';
                const maxVal = minMaxData[index].max !== -Infinity ? processValue(minMaxData[index].max, field.unit) : 'N/A';

                parity = !parity;
                const bColor = parity ? 'bg-white' : 'bg-gray-50/50';

                const row = `
                    <tr class="${bColor} hover:bg-blue-50/50 transition-colors">
                        <td class="px-6 py-4 font-medium text-gray-900 border-r border-gray-100">${fName}</td>
                        <td class="px-6 py-4 font-mono text-primary font-semibold">${curVal}</td>
                        <td class="px-6 py-4 font-mono text-gray-600 border-l border-gray-100">${minVal}</td>
                        <td class="px-6 py-4 font-mono text-gray-600">${maxVal}</td>
                    </tr>
                `;
                tbody.innerHTML += row;
            });
        }

        function updateChart() {
            if (cachedEvents.length === 0) {
                return; // Wait for at least one chunk before trying to chart
            }

            const isWater = activeDatasetType === 'waterDepth';
            const searchTag = isWater ? 'water_depth' : 'battery_voltage';

            // Apply water level filter to remove bad readings
            const filteredEvents = isWater ? filterWaterLevelEvents(cachedEvents) : cachedEvents;

            const dataIndex = fieldConfigs.findIndex(f => f.name.toLowerCase() === searchTag);
            if (dataIndex === -1) return;

            const targetField = fieldConfigs[dataIndex];
            const baseUnit = targetField.unit.replace(/ x\d+/, '');

            // Aggregate points into 15-minute buckets for performance and visual clarity
            const BUCKET_MS = 15 * 60 * 1000;
            const buckets = new Map();

            filteredEvents.forEach(evt => {
                const ts = Number(evt.args.timestamp) * 1000;
                const bucketTime = Math.floor(ts / BUCKET_MS) * BUCKET_MS;
                const val = processRawValue(evt.args.values[dataIndex], targetField.unit);

                if (!buckets.has(bucketTime)) {
                    buckets.set(bucketTime, { sum: 0, count: 0 });
                }
                const b = buckets.get(bucketTime);
                b.sum += val;
                b.count += 1;
            });

            // Convert map back into an array of {x, y} points sorted by time
            const points = Array.from(buckets.entries())
                .sort((a, b) => a[0] - b[0])
                .map(([time, data]) => ({
                    x: new Date(time),
                    y: data.sum / data.count
                }));

            const color = isWater ? '#3B82F6' : '#10B981';
            const bgColor = isWater ? 'rgba(59, 130, 246, 0.1)' : 'rgba(16, 185, 129, 0.1)';
            const title = isWater ? 'Water Depth Over Time' : 'Battery Voltage Over Time';

            document.getElementById('chartTitle').textContent = title;

            // Define the min/max dynamically from the data points
            const minChartY = isWater ? Math.min(...points.map(p => p.y)) * 0.99 : Math.min(...points.map(p => p.y)) - 0.2;
            const maxChartY = isWater ? Math.max(...points.map(p => p.y)) * 1.01 : Math.max(...points.map(p => p.y)) + 0.2;

            if (currentChart) {
                // Smoothly update existing chart
                currentChart.data.datasets[0].data = points;
                currentChart.data.datasets[0].label = isWater ? `Water Depth (${baseUnit})` : `Voltage (${baseUnit})`;
                currentChart.data.datasets[0].borderColor = color;
                currentChart.data.datasets[0].backgroundColor = bgColor;
                currentChart.options.scales.y.suggestedMin = minChartY;
                currentChart.options.scales.y.suggestedMax = maxChartY;
                currentChart.update('none'); // Update without full animations for progressive render speed
            } else {
                const ctx = document.getElementById('mainChart').getContext('2d');
                currentChart = new Chart(ctx, {
                    data: {
                        datasets: [{
                            label: isWater ? `Water Depth (${baseUnit})` : `Voltage (${baseUnit})`,
                            data: points,
                            borderColor: color,
                            backgroundColor: bgColor,
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: points.length > 50 ? 0 : 3,
                            pointHoverRadius: 6,
                        }]
                    },
                    type: 'line',
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                                titleColor: '#1e293b',
                                bodyColor: '#1e293b',
                                borderColor: '#e2e8f0',
                                borderWidth: 1,
                                padding: 12,
                                callbacks: {
                                    label: function (context) {
                                        return ` ${Number(context.parsed.y).toFixed(isWater ? 4 : 3)} ${baseUnit}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    tooltipFormat: 'MMM d, yyyy h:mm a',
                                    displayFormats: {
                                        hour: 'h:mm a',
                                        minute: 'h:mm a'
                                    }
                                },
                                grid: { display: false },
                                ticks: {
                                    maxTicksLimit: 8,
                                    font: { family: "'Inter', sans-serif" }
                                }
                            },
                            y: {
                                grid: { color: '#f1f5f9' },
                                ticks: {
                                    font: { family: "'Inter', sans-serif" },
                                    callback: function (value) {
                                        return Number(value).toFixed(isWater ? 2 : 1) + ' ' + baseUnit;
                                    }
                                },
                                suggestedMin: minChartY,
                                suggestedMax: maxChartY,
                            }
                        }
                    }
                });
            }
        }

        const btnWater = document.getElementById('toggleWater');
        const btnBattery = document.getElementById('toggleBattery');

        function setToggleState(type) {
            activeDatasetType = type;
            if (type === 'waterDepth') {
                btnWater.className = 'btn-toggle px-4 py-2 rounded-md text-sm font-semibold shadow-sm bg-white text-primary ring-1 ring-gray-200';
                btnBattery.className = 'btn-toggle px-4 py-2 rounded-md text-sm font-semibold text-gray-500 hover:text-gray-700 hover:bg-white/50 transition border border-transparent';
            } else {
                btnBattery.className = 'btn-toggle px-4 py-2 rounded-md text-sm font-semibold shadow-sm bg-white text-secondary ring-1 ring-gray-200';
                btnWater.className = 'btn-toggle px-4 py-2 rounded-md text-sm font-semibold text-gray-500 hover:text-gray-700 hover:bg-white/50 transition border border-transparent';
            }
            updateChart();
        }

        btnWater.addEventListener('click', () => setToggleState('waterDepth'));
        btnBattery.addEventListener('click', () => setToggleState('batteryVoltage'));
        storeSelector.addEventListener('change', () => initApp());

        // Initial Load
        window.addEventListener('load', () => { setTimeout(() => initApp(), 200) }) // delay to let tailwind parse initially
    </script>
</body>

</html>