<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Robot IK — สองแคว Workshop</title>
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0d1117; color: #e6edf3; font-family: -apple-system, 'Noto Sans Thai', sans-serif; overflow: hidden; }

  #canvas-container { width: 100vw; height: 100vh; }

  /* Webcam preview */
  #webcam-box {
    position: absolute; bottom: 16px; right: 16px; z-index: 100;
    border: 2px solid #30363d; border-radius: 12px; overflow: hidden;
    background: #161b22;
  }
  #webcam { width: 240px; height: 180px; object-fit: cover; transform: scaleX(-1); display: block; }
  #hand-canvas { position: absolute; top: 0; left: 0; width: 240px; height: 180px; transform: scaleX(-1); }

  /* Status bar */
  .hud {
    position: absolute; top: 12px; left: 12px; z-index: 100;
    background: rgba(13, 17, 23, 0.9); border: 1px solid #30363d;
    border-radius: 10px; padding: 12px 16px; font-size: 0.8rem;
    backdrop-filter: blur(8px); max-width: 340px;
  }
  .hud h2 { color: #58a6ff; font-size: 1rem; margin-bottom: 4px; }
  .hud .sub { color: #8b949e; font-size: 0.75rem; margin-bottom: 8px; }
  .status-row { display: flex; align-items: center; gap: 6px; margin: 4px 0; font-size: 0.75rem; }
  .dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .dot.on { background: #3fb950; box-shadow: 0 0 4px #3fb950; }
  .dot.off { background: #f87171; }
  .dot.wait { background: #f0883e; animation: pulse 1.5s infinite; }
  @keyframes pulse { 50% { opacity: 0.4; } }

  /* Emote display */
  .emote-badge {
    display: inline-block; padding: 2px 8px; border-radius: 4px;
    font-size: 0.7rem; font-weight: 600; margin-left: 4px;
    background: #1f3a5f; color: #58a6ff; transition: all 0.3s;
  }
  .emote-badge.active { background: #58a6ff; color: #0d1117; }

  /* Expression bar */
  .expr-bar {
    height: 4px; border-radius: 2px; margin-top: 4px;
    background: #21262d; overflow: hidden;
  }
  .expr-fill {
    height: 100%; border-radius: 2px; transition: width 0.3s;
    background: linear-gradient(90deg, #f87171, #fbbf24, #3fb950);
  }

  /* Controls */
  .controls {
    position: absolute; top: 12px; right: 12px; z-index: 100;
    background: rgba(13, 17, 23, 0.9); border: 1px solid #30363d;
    border-radius: 10px; padding: 12px 16px; backdrop-filter: blur(8px);
  }
  .controls button {
    display: block; width: 100%; padding: 8px 16px; margin: 4px 0;
    background: #21262d; border: 1px solid #30363d; border-radius: 6px;
    color: #e6edf3; font-size: 0.8rem; cursor: pointer;
  }
  .controls button:hover { border-color: #58a6ff; }
  .controls button.active { background: #1f3a5f; border-color: #58a6ff; color: #58a6ff; }
  .controls label { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; color: #8b949e; margin: 6px 0; }
  .controls select {
    width: 100%; padding: 6px 8px; margin: 4px 0;
    background: #21262d; border: 1px solid #30363d; border-radius: 6px;
    color: #e6edf3; font-size: 0.75rem;
  }

  /* Loading */
  .loading-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: #0d1117; display: flex; align-items: center; justify-content: center;
    z-index: 200; flex-direction: column; gap: 12px;
  }
  .loading-overlay.hidden { display: none; }
  .loading-text { color: #58a6ff; font-size: 1.1rem; }
  .loading-sub { color: #8b949e; font-size: 0.85rem; }

  footer {
    position: absolute; bottom: 16px; left: 16px; z-index: 100;
    color: #484f58; font-size: 0.7rem;
  }
  footer a { color: #58a6ff; text-decoration: none; }
</style>
</head>
<body>

<div class="loading-overlay" id="loading">
  <div class="loading-text">Loading RobotExpressive + MediaPipe...</div>
  <div class="loading-sub" id="load-status">Initializing Three.js...</div>
</div>

<div id="canvas-container"></div>

<!-- HUD -->
<div class="hud">
  <h2>Robot IK</h2>
  <div class="sub">มือของคุณควบคุม Robot — gesture + expression + MQTT</div>
  <div class="status-row"><div class="dot wait" id="dot-hand"></div><span id="status-hand">hand: waiting</span></div>
  <div class="status-row"><div class="dot wait" id="dot-mqtt"></div><span id="status-mqtt">mqtt: connecting...</span></div>
  <div class="status-row">
    <span id="status-gesture" style="color:#8b949e;">gesture: —</span>
    <span class="emote-badge" id="emote-badge">idle</span>
  </div>
  <div class="status-row"><span id="status-expr" style="color:#8b949e;">expression: —</span></div>
  <div class="expr-bar"><div class="expr-fill" id="expr-fill" style="width:50%"></div></div>
  <div class="status-row"><span id="status-fps" style="color:#484f58;">fps: —</span></div>
</div>

<!-- Controls -->
<div class="controls">
  <button id="btn-cam" onclick="toggleCamera()">Start Camera</button>
  <select id="sel-state" onchange="changeState(this.value)">
    <option value="Idle">Idle</option>
    <option value="Walking">Walking</option>
    <option value="Running">Running</option>
    <option value="Dance">Dance</option>
  </select>
  <label><input type="checkbox" id="chk-gesture" checked> Gesture → emote</label>
  <label><input type="checkbox" id="chk-expr" checked> Hand Y → expression</label>
  <label><input type="checkbox" id="chk-mqtt" checked> MQTT publish</label>
  <label><input type="checkbox" id="chk-subscribe" checked> MQTT subscribe</label>
</div>

<!-- Webcam -->
<div id="webcam-box" style="display:none;">
  <video id="webcam" autoplay playsinline></video>
  <canvas id="hand-canvas"></canvas>
</div>

<footer>
  <a href="index.html">PSRU Workshop</a> · <a href="hand-ik.html">Kira IK</a> · <a href="https://github.com/Soul-Brews-Studio/two-rivers-oracle">GitHub</a><br>
  Two Rivers (สองแคว) — RobotExpressive + Hand Tracking
</footer>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// ===== GLOBALS =====
let scene, camera, renderer, orbitControls;
let model, mixer, actions = {}, activeAction, previousAction;
let face; // Head_4 mesh for morph targets

// Animation categories
const states = ['Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing'];
const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'];

// Gesture → emote mapping
const gestureEmoteMap = {
  fist: 'Punch',
  open: 'Wave',
  peace: 'ThumbsUp',
  point: 'Yes',
};

// Hand tracking state
let handsData = { left: null, right: null };
let gestureData = { left: null, right: null };
let cameraActive = false;
let handDetector = null;

// Emote cooldown — prevent spamming
let emoteCooldown = false;
let currentGesture = null;
let currentBaseState = 'Idle';

// MQTT
let mqttClient = null;
const MQTT_TOPIC = 'hand/landmarks';
const MQTT_BROKER = 'wss://dustboy-wss-bridge.laris.workers.dev/mqtt';

// Config
const conf = {
  gestureEmote: true,
  handExpression: true,
  mqttPublish: true,
  mqttSubscribe: true,
};

// Timer for animation
const clock = new THREE.Clock();

// ===== INIT THREE.JS =====
async function init() {
  const container = document.getElementById('canvas-container');

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0d1117, 0.12);
  scene.background = new THREE.Color(0x0d1117);

  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 100);
  camera.position.set(-5, 3, 10);
  camera.lookAt(0, 2, 0);

  // Lighting
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x8d8d8d, 3);
  hemiLight.position.set(0, 20, 0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0x58a6ff, 3);
  dirLight.position.set(0, 20, 10);
  dirLight.castShadow = true;
  dirLight.shadow.camera.top = 4;
  dirLight.shadow.camera.bottom = -4;
  dirLight.shadow.camera.left = -4;
  dirLight.shadow.camera.right = 4;
  dirLight.shadow.camera.near = 0.1;
  dirLight.shadow.camera.far = 40;
  scene.add(dirLight);

  const rimLight = new THREE.DirectionalLight(0xf778ba, 1.5);
  rimLight.position.set(-5, 3, -5);
  scene.add(rimLight);

  // Ground
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.MeshPhongMaterial({ color: 0x161b22, depthWrite: false })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Grid
  const grid = new THREE.GridHelper(20, 40, 0x30363d, 0x21262d);
  grid.material.opacity = 0.5;
  grid.material.transparent = true;
  scene.add(grid);

  setLoadStatus('Loading RobotExpressive...');

  // Load model
  const loader = new GLTFLoader();
  const gltf = await loader.loadAsync(
    'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb'
  );

  model = gltf.scene;
  scene.add(model);

  // Setup animation mixer
  mixer = new THREE.AnimationMixer(model);

  // Pre-instantiate all actions
  for (const clip of gltf.animations) {
    const action = mixer.clipAction(clip);
    actions[clip.name] = action;

    if (emotes.includes(clip.name)) {
      action.clampWhenFinished = true;
      action.loop = THREE.LoopOnce;
    }
  }

  // Start with Idle
  activeAction = actions['Idle'];
  activeAction.play();

  // Find face mesh for morph targets
  face = model.getObjectByName('Head_4');
  if (face && face.morphTargetDictionary) {
    const exprNames = Object.keys(face.morphTargetDictionary);
    console.log('Morph targets:', exprNames.join(', '));
  }

  console.log('Animations:', Object.keys(actions).join(', '));

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.setAnimationLoop(animate);
  container.appendChild(renderer.domElement);

  // Orbit controls
  orbitControls = new OrbitControls(camera, renderer.domElement);
  orbitControls.enableDamping = true;
  orbitControls.target.set(0, 1, 0);
  orbitControls.update();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  setLoadStatus('Loading MediaPipe Hands...');
  await initMediaPipe();

  initMQTT();

  document.getElementById('loading').classList.add('hidden');
}

// ===== ANIMATION CROSSFADE =====
function fadeToAction(name, duration) {
  if (!actions[name]) return;
  previousAction = activeAction;
  activeAction = actions[name];

  if (previousAction !== activeAction) {
    previousAction.fadeOut(duration);
  }

  activeAction
    .reset()
    .setEffectiveTimeScale(1)
    .setEffectiveWeight(1)
    .fadeIn(duration)
    .play();
}

function triggerEmote(emoteName) {
  if (emoteCooldown || !actions[emoteName]) return;

  emoteCooldown = true;
  fadeToAction(emoteName, 0.2);

  // Update badge
  const badge = document.getElementById('emote-badge');
  badge.textContent = emoteName;
  badge.classList.add('active');

  function restoreState() {
    mixer.removeEventListener('finished', restoreState);
    fadeToAction(currentBaseState, 0.2);

    badge.textContent = currentBaseState.toLowerCase();
    badge.classList.remove('active');

    // Cooldown to prevent rapid re-triggering
    setTimeout(() => { emoteCooldown = false; }, 500);
  }

  mixer.addEventListener('finished', restoreState);
}

window.changeState = function(stateName) {
  if (!actions[stateName]) return;
  currentBaseState = stateName;
  fadeToAction(stateName, 0.5);
  document.getElementById('emote-badge').textContent = stateName.toLowerCase();
};

// ===== MORPH TARGET EXPRESSIONS =====
// Map hand Y position to expressions: high=happy, mid=neutral, low=sad
function updateExpressions(landmarks) {
  if (!face || !face.morphTargetDictionary || !conf.handExpression) return;
  if (!landmarks) return;

  // Use wrist Y (landmark 0) — normalized 0..1 (top=0, bottom=1)
  const wristY = landmarks[0].y;
  // Invert and remap: high hand = 1.0 (happy), low hand = 0.0 (sad)
  const mood = 1.0 - wristY;

  // Expression targets on RobotExpressive Head_4
  // The exact morph target names may vary — we'll try common ones
  const dict = face.morphTargetDictionary;

  // Reset all influences gradually
  for (let i = 0; i < face.morphTargetInfluences.length; i++) {
    face.morphTargetInfluences[i] *= 0.9; // Decay
  }

  // Map mood to expressions
  if (mood > 0.6) {
    // Happy zone — smile
    const strength = (mood - 0.6) / 0.4; // 0..1
    setMorph('Surprised', strength * 0.5);
    setExprLabel('happy', mood);
  } else if (mood < 0.4) {
    // Sad zone
    const strength = (0.4 - mood) / 0.4;
    setMorph('Angry', strength * 0.7);
    setExprLabel('sad', mood);
  } else {
    // Neutral
    setExprLabel('neutral', mood);
  }

  // Update expression bar
  document.getElementById('expr-fill').style.width = (mood * 100) + '%';
}

function setMorph(name, value) {
  if (!face || !face.morphTargetDictionary) return;
  const idx = face.morphTargetDictionary[name];
  if (idx !== undefined) {
    face.morphTargetInfluences[idx] = THREE.MathUtils.lerp(
      face.morphTargetInfluences[idx], value, 0.15
    );
  }
}

function setExprLabel(label, mood) {
  const el = document.getElementById('status-expr');
  el.textContent = `expression: ${label} (${(mood * 100).toFixed(0)}%)`;
  const colors = { happy: '#3fb950', neutral: '#8b949e', sad: '#f87171' };
  el.style.color = colors[label] || '#8b949e';
}

// ===== MEDIAPIPE HANDS =====
async function initMediaPipe() {
  const { HandLandmarker, FilesetResolver } = await import(
    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/+esm'
  );

  const vision = await FilesetResolver.forVisionTasks(
    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/wasm'
  );

  handDetector = await HandLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task',
      delegate: 'GPU'
    },
    runningMode: 'VIDEO',
    numHands: 2,
    minHandDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  setLoadStatus('MediaPipe ready');
}

// ===== WEBCAM =====
window.toggleCamera = async function() {
  const btn = document.getElementById('btn-cam');
  const box = document.getElementById('webcam-box');
  const video = document.getElementById('webcam');

  if (cameraActive) {
    const tracks = video.srcObject?.getTracks();
    tracks?.forEach(t => t.stop());
    video.srcObject = null;
    cameraActive = false;
    btn.textContent = 'Start Camera';
    btn.classList.remove('active');
    box.style.display = 'none';
    setHandStatus(false, 'stopped');
    return;
  }

  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { width: 640, height: 480, facingMode: 'user' }
    });
    video.srcObject = stream;
    await video.play();
    cameraActive = true;
    btn.textContent = 'Stop Camera';
    btn.classList.add('active');
    box.style.display = 'block';
    setHandStatus(true, 'tracking');
    detectHands();
  } catch (e) {
    setHandStatus(false, 'error: ' + e.message);
  }
};

let lastDetectTime = 0;
async function detectHands() {
  if (!cameraActive || !handDetector) return;

  const video = document.getElementById('webcam');
  const now = performance.now();

  if (now - lastDetectTime > 33) { // ~30fps
    lastDetectTime = now;
    const results = handDetector.detectForVideo(video, now);

    handsData = { left: null, right: null };
    gestureData = { left: null, right: null };

    if (results.landmarks && results.landmarks.length > 0) {
      const mqttHands = [];

      for (let i = 0; i < results.landmarks.length; i++) {
        const landmarks = results.landmarks[i];
        const handedness = results.handedness?.[i]?.[0]?.categoryName || 'Unknown';
        // MediaPipe mirrors: "Left" in camera = your right hand
        const side = handedness === 'Left' ? 'right' : 'left';

        handsData[side] = landmarks;
        gestureData[side] = detectGesture(landmarks);
        mqttHands.push({ handedness, landmarks: landmarks.map(l => ({ x: l.x, y: l.y, z: l.z })) });
      }

      drawHandOverlay(results.landmarks, results.handedness);

      // Process gestures → emotes
      processGestures();

      // Process hand position → expressions
      const primaryHand = handsData.right || handsData.left;
      updateExpressions(primaryHand);

      // Publish to MQTT
      if (conf.mqttPublish && mqttClient?.connected) {
        mqttClient.publish(MQTT_TOPIC, JSON.stringify({ timestamp: Date.now(), hands: mqttHands }));
      }

      updateGestureDisplay(gestureData.left, gestureData.right);
    } else {
      clearHandOverlay();
      updateGestureDisplay(null, null);
    }
  }

  requestAnimationFrame(detectHands);
}

// ===== GESTURE → EMOTE =====
function processGestures() {
  if (!conf.gestureEmote) return;

  // Use right hand gesture (dominant) or fall back to left
  const gesture = gestureData.right || gestureData.left;
  if (!gesture || gesture === 'neutral') {
    currentGesture = null;
    return;
  }

  // Only trigger on gesture change (not every frame)
  if (gesture !== currentGesture) {
    currentGesture = gesture;
    const emoteName = gestureEmoteMap[gesture];
    if (emoteName) {
      triggerEmote(emoteName);
    }
  }
}

// ===== GESTURE DETECTION =====
function detectGesture(landmarks) {
  if (!landmarks || landmarks.length < 21) return null;

  const fingers = [
    { name: 'index',  tip: landmarks[8],  pip: landmarks[6] },
    { name: 'middle', tip: landmarks[12], pip: landmarks[10] },
    { name: 'ring',   tip: landmarks[16], pip: landmarks[14] },
    { name: 'pinky',  tip: landmarks[20], pip: landmarks[18] },
  ];

  let curled = 0;
  let extended = 0;
  for (const f of fingers) {
    if (f.tip.y > f.pip.y) curled++;
    else extended++;
  }

  // Thumb check
  const thumbTip = landmarks[4];
  const thumbIP = landmarks[3];
  const thumbExtended = Math.abs(thumbTip.x - landmarks[0].x) > Math.abs(thumbIP.x - landmarks[0].x);

  if (curled >= 4) return 'fist';
  if (extended >= 4 && thumbExtended) return 'open';
  if (fingers[0].tip.y < fingers[0].pip.y && fingers[1].tip.y < fingers[1].pip.y && curled >= 2) return 'peace';
  if (fingers[0].tip.y < fingers[0].pip.y && curled >= 3) return 'point';

  return 'neutral';
}

// ===== HAND OVERLAY =====
function drawHandOverlay(allLandmarks, allHandedness) {
  const canvas = document.getElementById('hand-canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 240;
  canvas.height = 180;
  ctx.clearRect(0, 0, 240, 180);

  const connections = [
    [0,1],[1,2],[2,3],[3,4],
    [0,5],[5,6],[6,7],[7,8],
    [0,9],[9,10],[10,11],[11,12],
    [0,13],[13,14],[14,15],[15,16],
    [0,17],[17,18],[18,19],[19,20],
    [5,9],[9,13],[13,17]
  ];

  const colors = { Left: '#f778ba', Right: '#58a6ff' };

  for (let h = 0; h < allLandmarks.length; h++) {
    const landmarks = allLandmarks[h];
    const handedness = allHandedness?.[h]?.[0]?.categoryName || 'Unknown';
    const color = colors[handedness] || '#3fb950';

    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    for (const [a, b] of connections) {
      ctx.beginPath();
      ctx.moveTo(landmarks[a].x * 240, landmarks[a].y * 180);
      ctx.lineTo(landmarks[b].x * 240, landmarks[b].y * 180);
      ctx.stroke();
    }

    for (let i = 0; i < landmarks.length; i++) {
      const l = landmarks[i];
      ctx.beginPath();
      ctx.arc(l.x * 240, l.y * 180, i === 8 ? 5 : 2.5, 0, Math.PI * 2);
      ctx.fillStyle = i === 8 ? '#fbbf24' : color;
      ctx.fill();
    }
  }
}

function clearHandOverlay() {
  const canvas = document.getElementById('hand-canvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// ===== MQTT =====
function initMQTT() {
  mqttClient = mqtt.connect(MQTT_BROKER);

  mqttClient.on('connect', () => {
    setMQTTStatus(true, 'connected');
    if (conf.mqttSubscribe) {
      mqttClient.subscribe(MQTT_TOPIC);
    }
  });

  mqttClient.on('message', (topic, message) => {
    if (!conf.mqttSubscribe) return;
    if (cameraActive) return; // Local camera takes priority

    try {
      const data = JSON.parse(message.toString());
      if (data.hands && data.hands.length > 0) {
        handsData = { left: null, right: null };
        gestureData = { left: null, right: null };
        for (const hand of data.hands) {
          const side = hand.handedness === 'Left' ? 'right' : 'left';
          handsData[side] = hand.landmarks;
          gestureData[side] = detectGesture(hand.landmarks);
        }
        setHandStatus(true, 'mqtt remote');

        // Process remote gestures
        processGestures();
        const primaryHand = handsData.right || handsData.left;
        updateExpressions(primaryHand);

        updateGestureDisplay(gestureData.left, gestureData.right);
      }
    } catch {}
  });

  mqttClient.on('offline', () => setMQTTStatus(false, 'offline'));
  mqttClient.on('error', () => setMQTTStatus(false, 'error'));
}

// ===== ANIMATE =====
let frameCount = 0;
let lastFpsTime = performance.now();

function animate() {
  // FPS counter
  frameCount++;
  const now = performance.now();
  if (now - lastFpsTime > 1000) {
    document.getElementById('status-fps').textContent = `fps: ${frameCount}`;
    frameCount = 0;
    lastFpsTime = now;
  }

  // Update animation mixer
  const delta = clock.getDelta();
  if (mixer) {
    mixer.update(delta);
  }

  orbitControls.update();
  renderer.render(scene, camera);
}

// ===== UI HELPERS =====
function setLoadStatus(text) {
  document.getElementById('load-status').textContent = text;
}

function setHandStatus(on, text) {
  document.getElementById('dot-hand').className = on ? 'dot on' : 'dot off';
  document.getElementById('status-hand').textContent = 'hand: ' + text;
}

function setMQTTStatus(on, text) {
  document.getElementById('dot-mqtt').className = on ? 'dot on' : 'dot off';
  document.getElementById('status-mqtt').textContent = 'mqtt: ' + text;
}

function updateGestureDisplay(leftGesture, rightGesture) {
  const el = document.getElementById('status-gesture');
  const colors = { fist: '#f87171', open: '#3fb950', point: '#58a6ff', peace: '#fbbf24', neutral: '#8b949e' };
  const parts = [];
  if (leftGesture) parts.push(`L:${leftGesture}`);
  if (rightGesture) parts.push(`R:${rightGesture}`);
  if (parts.length === 0) { el.textContent = 'gesture: —'; el.style.color = '#8b949e'; return; }
  el.textContent = `gesture: ${parts.join(' ')}`;
  el.style.color = colors[rightGesture || leftGesture] || '#8b949e';
}

// Checkbox bindings
document.getElementById('chk-gesture').addEventListener('change', e => conf.gestureEmote = e.target.checked);
document.getElementById('chk-expr').addEventListener('change', e => conf.handExpression = e.target.checked);
document.getElementById('chk-mqtt').addEventListener('change', e => conf.mqttPublish = e.target.checked);
document.getElementById('chk-subscribe').addEventListener('change', e => {
  conf.mqttSubscribe = e.target.checked;
  if (mqttClient?.connected) {
    if (e.target.checked) mqttClient.subscribe(MQTT_TOPIC);
    else mqttClient.unsubscribe(MQTT_TOPIC);
  }
});

// ===== START =====
init().catch(e => {
  setLoadStatus('Error: ' + e.message);
  console.error(e);
});
</script>
</body>
</html>
