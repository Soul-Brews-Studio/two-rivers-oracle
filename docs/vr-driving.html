<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VR Driving License Test — สองแคว Workshop</title>
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/" } }</script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0d1117; color: #e6edf3; font-family: -apple-system, 'Noto Sans Thai', sans-serif; overflow: hidden; }

  canvas { display: block; width: 100vw; height: 100vh; }

  /* HUD Overlay */
  .hud { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 10; }
  .hud > * { pointer-events: auto; }

  .header {
    display: flex; align-items: center; gap: 12px;
    padding: 8px 16px; background: rgba(22,27,34,0.85); border-bottom: 1px solid #30363d;
  }
  .header h1 {
    font-size: 1.2rem;
    background: linear-gradient(135deg, #58a6ff, #3fb950);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .header .sub { color: #8b949e; font-size: 0.75rem; }
  .header .links { margin-left: auto; font-size: 0.7rem; }
  .header .links a { color: #58a6ff; text-decoration: none; margin-left: 12px; }

  .status-row { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; }
  .dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .dot.on { background: #3fb950; box-shadow: 0 0 4px #3fb950; }
  .dot.off { background: #f87171; }
  .dot.wait { background: #f0883e; animation: pulse 1.5s infinite; }
  @keyframes pulse { 50% { opacity: 0.4; } }

  /* Speedometer */
  .speedometer {
    position: fixed; bottom: 20px; left: 20px; width: 180px; height: 180px; z-index: 15;
  }
  .speedometer canvas { width: 100%; height: 100%; }

  /* Score panel */
  .score-panel {
    position: fixed; top: 60px; right: 16px; width: 200px;
    background: rgba(22,27,34,0.9); border: 1px solid #30363d; border-radius: 12px;
    padding: 16px; z-index: 15;
  }
  .score-panel .score-val {
    font-size: 2.5rem; font-weight: 800; text-align: center;
    background: linear-gradient(135deg, #3fb950, #58a6ff);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .score-panel .score-label { text-align: center; color: #8b949e; font-size: 0.7rem; }
  .score-panel .grade {
    text-align: center; font-size: 1.4rem; font-weight: 700; margin-top: 4px;
  }

  /* Feedback messages */
  .feedback-container {
    position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
    z-index: 15; display: flex; flex-direction: column; align-items: center; gap: 4px;
    pointer-events: none;
  }
  .feedback-msg {
    padding: 6px 16px; border-radius: 8px; font-size: 0.85rem; font-weight: 600;
    animation: feedbackFade 2.5s ease forwards;
    white-space: nowrap;
  }
  .feedback-msg.positive { background: rgba(63,185,80,0.2); color: #3fb950; border: 1px solid rgba(63,185,80,0.3); }
  .feedback-msg.negative { background: rgba(248,113,113,0.2); color: #f87171; border: 1px solid rgba(248,113,113,0.3); }
  @keyframes feedbackFade {
    0% { opacity: 0; transform: translateY(10px); }
    15% { opacity: 1; transform: translateY(0); }
    70% { opacity: 1; }
    100% { opacity: 0; transform: translateY(-20px); }
  }

  /* Turn signals & brake */
  .indicators {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 24px; z-index: 15;
  }
  .indicator {
    width: 40px; height: 40px; border-radius: 8px; display: flex;
    align-items: center; justify-content: center; font-size: 1.2rem;
    background: rgba(22,27,34,0.8); border: 1px solid #30363d; color: #484f58;
    transition: all 0.15s;
  }
  .indicator.active-left, .indicator.active-right {
    background: rgba(251,191,36,0.2); border-color: #fbbf24; color: #fbbf24;
  }
  .indicator.active-brake {
    background: rgba(248,113,113,0.3); border-color: #f87171; color: #f87171;
  }

  /* Scenario selector */
  .scenario-select {
    position: fixed; top: 60px; left: 16px; z-index: 15;
    background: rgba(22,27,34,0.9); border: 1px solid #30363d; border-radius: 12px;
    padding: 12px;
  }
  .scenario-select h3 { color: #8b949e; font-size: 0.7rem; text-transform: uppercase; margin-bottom: 8px; }
  .scenario-btn {
    display: block; width: 100%; padding: 6px 10px; margin-bottom: 4px;
    background: #21262d; border: 1px solid #30363d; border-radius: 6px;
    color: #8b949e; font-size: 0.75rem; cursor: pointer; text-align: left;
    font-family: inherit;
  }
  .scenario-btn:hover { border-color: #58a6ff; }
  .scenario-btn.active { background: #1f3a5f; border-color: #58a6ff; color: #58a6ff; }

  /* Session summary overlay */
  .summary-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.8);
    display: none; align-items: center; justify-content: center; z-index: 50;
  }
  .summary-overlay.open { display: flex; }
  .summary-box {
    background: #161b22; border: 1px solid #30363d; border-radius: 16px;
    padding: 32px; max-width: 400px; width: 90%; text-align: center;
  }
  .summary-box h2 {
    color: #58a6ff; font-size: 1.5rem; margin-bottom: 16px;
  }
  .summary-box .final-grade {
    font-size: 4rem; font-weight: 800; margin: 12px 0;
  }
  .summary-box .final-score { font-size: 1.2rem; color: #8b949e; margin-bottom: 16px; }
  .summary-box .event-list {
    text-align: left; max-height: 200px; overflow-y: auto;
    margin-bottom: 16px; font-size: 0.8rem;
  }
  .summary-box .event-list div { padding: 3px 0; border-bottom: 1px solid #21262d; }
  .summary-box button {
    padding: 10px 24px; background: #58a6ff; color: #0d1117; border: none;
    border-radius: 8px; font-size: 1rem; font-weight: 700; cursor: pointer;
    font-family: inherit;
  }

  /* Instructions */
  .drive-instructions {
    position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
    background: rgba(22,27,34,0.85); border: 1px solid #30363d; border-radius: 8px;
    padding: 8px 16px; z-index: 15; font-size: 0.7rem; color: #8b949e; text-align: center;
    transition: opacity 0.5s;
  }
  .drive-instructions kbd {
    display: inline-block; padding: 1px 6px; background: #21262d; border: 1px solid #30363d;
    border-radius: 4px; color: #e6edf3; font-family: monospace; font-size: 0.7rem;
  }
</style>
</head>
<body>

<div class="hud">
  <div class="header">
    <h1>VR Driving License Test</h1>
    <span class="sub">ฝึกขับรถ + AI Scoring</span>
    <div class="status-row" style="margin-left:12px;">
      <div class="dot wait" id="dot-mqtt"></div>
      <span id="status-mqtt">mqtt: connecting...</span>
    </div>
    <div class="links">
      <a href="index.html">Workshop</a>
      <a href="arena.html">Arena</a>
      <a href="https://github.com/Soul-Brews-Studio/two-rivers-oracle">GitHub</a>
    </div>
  </div>
</div>

<div class="speedometer" id="speedo-container">
  <canvas id="speedo-canvas" width="360" height="360"></canvas>
</div>

<div class="score-panel">
  <div class="score-val" id="score-val">100</div>
  <div class="score-label">คะแนน</div>
  <div class="grade" id="grade-val" style="color:#3fb950;">A</div>
</div>

<div class="feedback-container" id="feedback-container"></div>

<div class="indicators">
  <div class="indicator" id="ind-left">&#9664;</div>
  <div class="indicator" id="ind-brake">B</div>
  <div class="indicator" id="ind-right">&#9654;</div>
</div>

<div class="scenario-select" id="scenario-select">
  <h3>Scenario</h3>
  <button class="scenario-btn active" data-scenario="city">City Driving</button>
  <button class="scenario-btn" data-scenario="highway">Highway</button>
  <button class="scenario-btn" data-scenario="parking">Parking</button>
  <button class="scenario-btn" data-scenario="emergency">Emergency Brake</button>
</div>

<div class="drive-instructions" id="drive-instructions">
  <kbd>W</kbd> เร่ง &nbsp; <kbd>S</kbd> เบรก &nbsp; <kbd>A</kbd>/<kbd>D</kbd> เลี้ยว &nbsp;
  <kbd>Q</kbd>/<kbd>E</kbd> ไฟเลี้ยว
</div>

<div class="summary-overlay" id="summary-overlay">
  <div class="summary-box">
    <h2>Session Summary</h2>
    <div class="final-grade" id="final-grade">A</div>
    <div class="final-score" id="final-score">100 คะแนน</div>
    <div class="event-list" id="event-list"></div>
    <button onclick="restartSession()">เริ่มใหม่</button>
  </div>
</div>

<script type="module">
import * as THREE from 'three';

// ===== CONSTANTS =====
const MQTT_BROKER = 'wss://dustboy-wss-bridge.laris.workers.dev/mqtt';

// ===== DRIVING STATE =====
let speed = 0; // km/h
let steerAngle = 0;
let carX = 0, carZ = 0, carAngle = 0;
let score = 100;
let braking = false;
let turnSignalLeft = false, turnSignalRight = false;
let lastSpeed = 0;
let events = [];
let sessionActive = true;
let distanceTraveled = 0;
let currentScenario = 'city';
let speedLimit = 60; // km/h for current scenario

const SCENARIOS = {
  city: { speedLimit: 60, label: 'City' },
  highway: { speedLimit: 120, label: 'Highway' },
  parking: { speedLimit: 20, label: 'Parking' },
  emergency: { speedLimit: 80, label: 'Emergency' },
};

// ===== THREE.JS SETUP =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 80, 200);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.prepend(renderer.domElement);

// ===== LIGHTING =====
const ambient = new THREE.AmbientLight(0x8899bb, 0.7);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffee, 1.0);
sun.position.set(30, 50, 20);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.left = -60;
sun.shadow.camera.right = 60;
sun.shadow.camera.top = 60;
sun.shadow.camera.bottom = -60;
scene.add(sun);

// ===== GROUND =====
const groundGeo = new THREE.PlaneGeometry(400, 400);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x4a7c3f, roughness: 0.9 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
ground.receiveShadow = true;
scene.add(ground);

// ===== ROAD BUILDING =====
const roadGroup = new THREE.Group();
scene.add(roadGroup);

const roadMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.85 });
const lineMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
const yellowLineMat = new THREE.MeshStandardMaterial({ color: 0xfbbf24 });

// Road waypoints for a circuit
const ROAD_POINTS = [
  { x: 0, z: 0 }, { x: 0, z: -30 }, { x: 0, z: -60 },
  { x: 10, z: -80 }, { x: 30, z: -90 }, { x: 60, z: -90 },
  { x: 80, z: -80 }, { x: 90, z: -60 }, { x: 90, z: -30 },
  { x: 90, z: 0 }, { x: 80, z: 20 }, { x: 60, z: 30 },
  { x: 30, z: 30 }, { x: 10, z: 20 },
];

// Generate road segments from waypoints
const roadWidth = 8;
const roadSegments = [];

function buildRoad() {
  // Create a smooth path from waypoints
  const curve = new THREE.CatmullRomCurve3(
    ROAD_POINTS.map(p => new THREE.Vector3(p.x, 0, p.z)),
    true // closed
  );

  const points = curve.getSpacedPoints(200);

  // Road surface segments
  for (let i = 0; i < points.length; i++) {
    const curr = points[i];
    const next = points[(i + 1) % points.length];
    const dir = new THREE.Vector3().subVectors(next, curr).normalize();
    const angle = Math.atan2(dir.x, dir.z);

    const segLen = curr.distanceTo(next) + 0.1;
    const seg = new THREE.Mesh(
      new THREE.PlaneGeometry(roadWidth, segLen),
      roadMat
    );
    seg.rotation.x = -Math.PI / 2;
    seg.rotation.z = -angle;
    seg.position.set(
      (curr.x + next.x) / 2,
      0.01,
      (curr.z + next.z) / 2
    );
    seg.receiveShadow = true;
    roadGroup.add(seg);

    roadSegments.push({ x: curr.x, z: curr.z, angle });
  }

  // Dashed center line
  for (let i = 0; i < points.length; i += 3) {
    const curr = points[i];
    const next = points[(i + 1) % points.length];
    const dir = new THREE.Vector3().subVectors(next, curr).normalize();
    const angle = Math.atan2(dir.x, dir.z);

    const dash = new THREE.Mesh(
      new THREE.PlaneGeometry(0.15, 1.2),
      lineMat
    );
    dash.rotation.x = -Math.PI / 2;
    dash.rotation.z = -angle;
    dash.position.set(curr.x, 0.02, curr.z);
    roadGroup.add(dash);
  }

  // Edge lines (solid yellow)
  for (let side = -1; side <= 1; side += 2) {
    for (let i = 0; i < points.length; i++) {
      const curr = points[i];
      const next = points[(i + 1) % points.length];
      const dir = new THREE.Vector3().subVectors(next, curr).normalize();
      const angle = Math.atan2(dir.x, dir.z);
      const perp = new THREE.Vector3(-dir.z, 0, dir.x);

      const segLen = curr.distanceTo(next) + 0.05;
      const edgeLine = new THREE.Mesh(
        new THREE.PlaneGeometry(0.12, segLen),
        yellowLineMat
      );
      edgeLine.rotation.x = -Math.PI / 2;
      edgeLine.rotation.z = -angle;
      edgeLine.position.set(
        (curr.x + next.x) / 2 + perp.x * (roadWidth / 2 - 0.2) * side,
        0.02,
        (curr.z + next.z) / 2 + perp.z * (roadWidth / 2 - 0.2) * side
      );
      roadGroup.add(edgeLine);
    }
  }

  return { curve, points };
}

const { curve: roadCurve, points: roadPoints } = buildRoad();

// ===== TRAFFIC SIGNS =====
const signs = [];

function createSign(type, x, z, faceAngle) {
  const group = new THREE.Group();
  // Pole
  const pole = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8),
    new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6 })
  );
  pole.position.y = 1.25;
  group.add(pole);

  if (type === 'stop') {
    // Red octagon
    const shape = new THREE.Shape();
    const r = 0.4;
    for (let i = 0; i < 8; i++) {
      const a = (i / 8) * Math.PI * 2 - Math.PI / 8;
      const px = Math.cos(a) * r;
      const py = Math.sin(a) * r;
      if (i === 0) shape.moveTo(px, py);
      else shape.lineTo(px, py);
    }
    shape.closePath();
    const sign = new THREE.Mesh(
      new THREE.ShapeGeometry(shape),
      new THREE.MeshStandardMaterial({ color: 0xcc0000, side: THREE.DoubleSide })
    );
    sign.position.y = 2.5;
    sign.rotation.y = faceAngle;
    group.add(sign);

    // STOP text (white plane on top)
    const textCanvas = document.createElement('canvas');
    textCanvas.width = 128; textCanvas.height = 128;
    const tctx = textCanvas.getContext('2d');
    tctx.fillStyle = '#cc0000';
    tctx.fillRect(0, 0, 128, 128);
    tctx.fillStyle = '#ffffff';
    tctx.font = 'bold 48px sans-serif';
    tctx.textAlign = 'center';
    tctx.textBaseline = 'middle';
    tctx.fillText('STOP', 64, 64);
    const textTex = new THREE.CanvasTexture(textCanvas);
    const textMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(0.6, 0.6),
      new THREE.MeshBasicMaterial({ map: textTex, transparent: true, side: THREE.DoubleSide })
    );
    textMesh.position.y = 2.5;
    textMesh.position.z = 0.01;
    textMesh.rotation.y = faceAngle;
    group.add(textMesh);
  } else if (type === 'speed') {
    // White circle with red border
    const sign = new THREE.Mesh(
      new THREE.CircleGeometry(0.4, 24),
      new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide })
    );
    sign.position.y = 2.5;
    sign.rotation.y = faceAngle;
    group.add(sign);
    const border = new THREE.Mesh(
      new THREE.RingGeometry(0.35, 0.42, 24),
      new THREE.MeshStandardMaterial({ color: 0xcc0000, side: THREE.DoubleSide })
    );
    border.position.y = 2.5;
    border.position.z = 0.01;
    border.rotation.y = faceAngle;
    group.add(border);
    // Speed number
    const numCanvas = document.createElement('canvas');
    numCanvas.width = 128; numCanvas.height = 128;
    const nctx = numCanvas.getContext('2d');
    nctx.fillStyle = '#ffffff';
    nctx.fillRect(0, 0, 128, 128);
    nctx.fillStyle = '#000000';
    nctx.font = 'bold 64px sans-serif';
    nctx.textAlign = 'center';
    nctx.textBaseline = 'middle';
    nctx.fillText(String(speedLimit), 64, 64);
    const numTex = new THREE.CanvasTexture(numCanvas);
    const numMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(0.5, 0.5),
      new THREE.MeshBasicMaterial({ map: numTex, transparent: true, side: THREE.DoubleSide })
    );
    numMesh.position.y = 2.5;
    numMesh.position.z = 0.02;
    numMesh.rotation.y = faceAngle;
    group.add(numMesh);
  } else if (type === 'curve') {
    // Yellow triangle
    const triShape = new THREE.Shape();
    triShape.moveTo(0, 0.4);
    triShape.lineTo(-0.35, -0.2);
    triShape.lineTo(0.35, -0.2);
    triShape.closePath();
    const sign = new THREE.Mesh(
      new THREE.ShapeGeometry(triShape),
      new THREE.MeshStandardMaterial({ color: 0xfbbf24, side: THREE.DoubleSide })
    );
    sign.position.y = 2.5;
    sign.rotation.y = faceAngle;
    group.add(sign);
  }

  group.position.set(x, 0, z);
  group.userData = { signType: type, x, z };
  signs.push(group);
  scene.add(group);
  return group;
}

// Place signs at key locations along road
createSign('stop', -5, -25, 0);
createSign('speed', -5, -55, 0);
createSign('curve', 5, -75, Math.PI / 4);
createSign('stop', 95, -55, Math.PI);
createSign('curve', 85, -15, -Math.PI / 4);
createSign('speed', 65, 35, Math.PI);
createSign('curve', 15, 25, -Math.PI * 3 / 4);

// ===== TREES =====
function createTree(x, z) {
  const group = new THREE.Group();
  // Trunk
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15, 0.2, 1.5, 6),
    new THREE.MeshStandardMaterial({ color: 0x8B5A2B })
  );
  trunk.position.y = 0.75;
  trunk.castShadow = true;
  group.add(trunk);
  // Canopy
  const canopy = new THREE.Mesh(
    new THREE.ConeGeometry(1.2, 2.5, 8),
    new THREE.MeshStandardMaterial({ color: 0x2d6b2d + Math.floor(Math.random() * 0x1a1a1a) })
  );
  canopy.position.y = 2.5;
  canopy.castShadow = true;
  group.add(canopy);
  group.position.set(x, 0, z);
  scene.add(group);
}

// Line trees along road edges
const treeSpacing = 12;
for (let i = 0; i < roadPoints.length; i += Math.floor(roadPoints.length / 30)) {
  const p = roadPoints[i];
  const next = roadPoints[(i + 1) % roadPoints.length];
  const dir = new THREE.Vector3().subVectors(next, p).normalize();
  const perp = new THREE.Vector3(-dir.z, 0, dir.x);
  // Trees on both sides
  for (const side of [-1, 1]) {
    const offset = (roadWidth / 2 + 2 + Math.random() * 3) * side;
    createTree(p.x + perp.x * offset, p.z + perp.z * offset);
  }
}

// ===== CAR MODEL =====
const carGroup = new THREE.Group();

// Body
const carBody = new THREE.Mesh(
  new THREE.BoxGeometry(2, 0.6, 4),
  new THREE.MeshStandardMaterial({ color: 0x3b82f6, roughness: 0.3, metalness: 0.5 })
);
carBody.position.y = 0.6;
carBody.castShadow = true;
carGroup.add(carBody);

// Roof
const carRoof = new THREE.Mesh(
  new THREE.BoxGeometry(1.6, 0.5, 2),
  new THREE.MeshStandardMaterial({ color: 0x2563eb, roughness: 0.3, metalness: 0.5 })
);
carRoof.position.set(0, 1.15, -0.3);
carRoof.castShadow = true;
carGroup.add(carRoof);

// Windshield
const windshield = new THREE.Mesh(
  new THREE.PlaneGeometry(1.5, 0.45),
  new THREE.MeshStandardMaterial({ color: 0x88bbff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
);
windshield.position.set(0, 1.1, 0.72);
windshield.rotation.x = -0.3;
carGroup.add(windshield);

// Wheels
const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 12);
const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
const wheelPositions = [
  [-1.0, 0.3, 1.2], [1.0, 0.3, 1.2],
  [-1.0, 0.3, -1.2], [1.0, 0.3, -1.2],
];
const wheels = [];
for (const [wx, wy, wz] of wheelPositions) {
  const wheel = new THREE.Mesh(wheelGeo, wheelMat);
  wheel.rotation.z = Math.PI / 2;
  wheel.position.set(wx, wy, wz);
  wheels.push(wheel);
  carGroup.add(wheel);
}

// Headlights
for (const side of [-0.7, 0.7]) {
  const headlight = new THREE.Mesh(
    new THREE.SphereGeometry(0.12, 8, 8),
    new THREE.MeshStandardMaterial({ color: 0xffffcc, emissive: 0xffffcc, emissiveIntensity: 0.5 })
  );
  headlight.position.set(side, 0.6, 2.0);
  carGroup.add(headlight);
}

// Tail lights
const tailLightLeft = new THREE.Mesh(
  new THREE.BoxGeometry(0.2, 0.1, 0.05),
  new THREE.MeshStandardMaterial({ color: 0xff2222, emissive: 0xff0000, emissiveIntensity: 0.3 })
);
tailLightLeft.position.set(-0.8, 0.6, -2.0);
carGroup.add(tailLightLeft);
const tailLightRight = tailLightLeft.clone();
tailLightRight.position.x = 0.8;
carGroup.add(tailLightRight);

// Turn signal meshes
const turnSignalLMesh = new THREE.Mesh(
  new THREE.BoxGeometry(0.15, 0.08, 0.05),
  new THREE.MeshStandardMaterial({ color: 0x443300, emissive: 0x000000 })
);
turnSignalLMesh.position.set(-1.01, 0.5, 1.8);
carGroup.add(turnSignalLMesh);
const turnSignalRMesh = turnSignalLMesh.clone();
turnSignalRMesh.position.x = 1.01;
carGroup.add(turnSignalRMesh);

carGroup.position.set(0, 0, 5);
scene.add(carGroup);

// ===== INPUT =====
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'KeyQ') { turnSignalLeft = !turnSignalLeft; turnSignalRight = false; }
  if (e.code === 'KeyE') { turnSignalRight = !turnSignalRight; turnSignalLeft = false; }
  if (e.code === 'KeyR') { showSummary(); }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Scenario selection
document.getElementById('scenario-select').addEventListener('click', e => {
  const btn = e.target.closest('.scenario-btn');
  if (!btn) return;
  document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  currentScenario = btn.dataset.scenario;
  speedLimit = SCENARIOS[currentScenario].speedLimit;
  restartSession();
});

// ===== SPEEDOMETER =====
const speedoCanvas = document.getElementById('speedo-canvas');
const sCtx = speedoCanvas.getContext('2d');

function drawSpeedometer(currentSpeed) {
  const w = 360, h = 360, cx = w / 2, cy = h / 2, r = 140;
  sCtx.clearRect(0, 0, w, h);

  // Background
  sCtx.beginPath();
  sCtx.arc(cx, cy, r + 10, 0, Math.PI * 2);
  sCtx.fillStyle = 'rgba(22,27,34,0.9)';
  sCtx.fill();
  sCtx.strokeStyle = '#30363d';
  sCtx.lineWidth = 2;
  sCtx.stroke();

  // Speed arc background
  const startAngle = Math.PI * 0.75;
  const endAngle = Math.PI * 2.25;

  sCtx.beginPath();
  sCtx.arc(cx, cy, r - 5, startAngle, endAngle);
  sCtx.strokeStyle = '#21262d';
  sCtx.lineWidth = 12;
  sCtx.stroke();

  // Speed arc fill
  const speedFrac = Math.min(currentSpeed / 120, 1);
  const speedAngle = startAngle + speedFrac * (endAngle - startAngle);
  const gradient = sCtx.createLinearGradient(0, h, w, 0);
  gradient.addColorStop(0, '#3fb950');
  gradient.addColorStop(0.5, '#fbbf24');
  gradient.addColorStop(1, '#f87171');

  sCtx.beginPath();
  sCtx.arc(cx, cy, r - 5, startAngle, speedAngle);
  sCtx.strokeStyle = gradient;
  sCtx.lineWidth = 12;
  sCtx.stroke();

  // Tick marks
  for (let i = 0; i <= 12; i++) {
    const a = startAngle + (i / 12) * (endAngle - startAngle);
    const innerR = i % 3 === 0 ? r - 30 : r - 22;
    sCtx.beginPath();
    sCtx.moveTo(cx + Math.cos(a) * innerR, cy + Math.sin(a) * innerR);
    sCtx.lineTo(cx + Math.cos(a) * (r - 14), cy + Math.sin(a) * (r - 14));
    sCtx.strokeStyle = i % 3 === 0 ? '#e6edf3' : '#484f58';
    sCtx.lineWidth = i % 3 === 0 ? 2 : 1;
    sCtx.stroke();

    if (i % 3 === 0) {
      sCtx.fillStyle = '#8b949e';
      sCtx.font = '14px sans-serif';
      sCtx.textAlign = 'center';
      sCtx.textBaseline = 'middle';
      const val = (i / 12) * 120;
      sCtx.fillText(String(Math.round(val)), cx + Math.cos(a) * (r - 40), cy + Math.sin(a) * (r - 40));
    }
  }

  // Speed limit marker
  const limitFrac = Math.min(speedLimit / 120, 1);
  const limitAngle = startAngle + limitFrac * (endAngle - startAngle);
  sCtx.beginPath();
  sCtx.arc(cx + Math.cos(limitAngle) * (r - 5), cy + Math.sin(limitAngle) * (r - 5), 6, 0, Math.PI * 2);
  sCtx.fillStyle = '#f87171';
  sCtx.fill();

  // Needle
  const needleAngle = startAngle + speedFrac * (endAngle - startAngle);
  sCtx.save();
  sCtx.translate(cx, cy);
  sCtx.rotate(needleAngle);
  sCtx.beginPath();
  sCtx.moveTo(0, -3);
  sCtx.lineTo(r - 25, 0);
  sCtx.lineTo(0, 3);
  sCtx.closePath();
  sCtx.fillStyle = currentSpeed > speedLimit ? '#f87171' : '#e6edf3';
  sCtx.fill();
  sCtx.restore();

  // Center cap
  sCtx.beginPath();
  sCtx.arc(cx, cy, 12, 0, Math.PI * 2);
  sCtx.fillStyle = '#30363d';
  sCtx.fill();

  // Speed number
  sCtx.fillStyle = currentSpeed > speedLimit ? '#f87171' : '#e6edf3';
  sCtx.font = 'bold 42px sans-serif';
  sCtx.textAlign = 'center';
  sCtx.textBaseline = 'middle';
  sCtx.fillText(String(Math.round(currentSpeed)), cx, cy + 45);
  sCtx.fillStyle = '#8b949e';
  sCtx.font = '14px sans-serif';
  sCtx.fillText('km/h', cx, cy + 68);
}

// ===== FEEDBACK =====
function showFeedback(text, positive) {
  const container = document.getElementById('feedback-container');
  const el = document.createElement('div');
  el.className = 'feedback-msg ' + (positive ? 'positive' : 'negative');
  el.textContent = text;
  container.appendChild(el);
  events.push({ text, positive, time: Date.now() });
  setTimeout(() => el.remove(), 2500);
}

function getGrade(s) {
  if (s >= 90) return { grade: 'A', color: '#3fb950' };
  if (s >= 80) return { grade: 'B', color: '#58a6ff' };
  if (s >= 70) return { grade: 'C', color: '#fbbf24' };
  if (s >= 60) return { grade: 'D', color: '#f0883e' };
  return { grade: 'F', color: '#f87171' };
}

function updateScoreDisplay() {
  const s = Math.max(0, Math.round(score));
  document.getElementById('score-val').textContent = s;
  const { grade, color } = getGrade(s);
  const gradeEl = document.getElementById('grade-val');
  gradeEl.textContent = grade;
  gradeEl.style.color = color;
}

// ===== SUMMARY =====
function showSummary() {
  sessionActive = false;
  const s = Math.max(0, Math.round(score));
  const { grade, color } = getGrade(s);
  document.getElementById('final-grade').textContent = grade;
  document.getElementById('final-grade').style.color = color;
  document.getElementById('final-score').textContent = s + ' คะแนน';

  const list = document.getElementById('event-list');
  list.innerHTML = '';
  events.forEach(ev => {
    const div = document.createElement('div');
    div.style.color = ev.positive ? '#3fb950' : '#f87171';
    div.textContent = ev.text;
    list.appendChild(div);
  });

  document.getElementById('summary-overlay').classList.add('open');
}

window.restartSession = function() {
  sessionActive = true;
  score = 100;
  speed = 0;
  steerAngle = 0;
  carX = 0; carZ = 5; carAngle = 0;
  events = [];
  distanceTraveled = 0;
  lastSpeed = 0;
  updateScoreDisplay();
  document.getElementById('summary-overlay').classList.remove('open');
};

// ===== SCORING LOGIC =====
let speedingTimer = 0;
let lastBrakeTime = 0;
let nearStopSign = false;
let stoppedAtSign = false;
let turnScoreTimer = 0;
const scoredStopSigns = new Set();

function checkScoring(dt) {
  if (!sessionActive) return;

  // Speeding check
  if (speed > speedLimit + 5) {
    speedingTimer += dt;
    if (speedingTimer > 2) {
      score -= 3;
      showFeedback(`ขับเร็วเกินกำหนด (${Math.round(speed)}/${speedLimit} km/h) -3 คะแนน`, false);
      speedingTimer = 0;
      publishEvent('speeding');
    }
  } else {
    speedingTimer = 0;
  }

  // Sudden brake check
  const decel = lastSpeed - speed;
  if (decel > 15 && braking) {
    score -= 5;
    showFeedback('เบรกกะทันหัน -5 คะแนน', false);
    publishEvent('sudden_brake');
  }

  // Stop sign check
  const carPos2D = new THREE.Vector2(carX, carZ);
  let currentlyNearStop = false;
  for (const sign of signs) {
    if (sign.userData.signType !== 'stop') continue;
    const signPos = new THREE.Vector2(sign.userData.x, sign.userData.z);
    const dist = carPos2D.distanceTo(signPos);
    if (dist < 8) {
      currentlyNearStop = true;
      const signKey = `${sign.userData.x},${sign.userData.z}`;
      if (speed < 3 && !scoredStopSigns.has(signKey)) {
        scoredStopSigns.add(signKey);
        score += 5;
        showFeedback('หยุดที่ป้ายสต็อป +5 คะแนน', true);
        stoppedAtSign = true;
        publishEvent('stop_sign_good');
      }
      if (dist < 4 && speed > 20 && !scoredStopSigns.has(signKey)) {
        scoredStopSigns.add(signKey);
        score -= 5;
        showFeedback('ไม่หยุดที่ป้ายสต็อป -5 คะแนน', false);
        publishEvent('stop_sign_miss');
      }
    }
  }

  // Good turning bonus
  if (Math.abs(steerAngle) > 0.3 && speed > 10 && speed < speedLimit * 0.8) {
    turnScoreTimer += dt;
    if (turnScoreTimer > 3) {
      score += 3;
      showFeedback('เลี้ยวดี +3 คะแนน', true);
      turnScoreTimer = 0;
      publishEvent('good_turn');
    }
  } else {
    turnScoreTimer = Math.max(0, turnScoreTimer - dt * 0.5);
  }

  // Clamp score
  score = Math.max(0, Math.min(150, score));
  updateScoreDisplay();
}

// ===== MQTT =====
let mqttClient = null;
function initMQTT() {
  try {
    mqttClient = mqtt.connect(MQTT_BROKER);
    mqttClient.on('connect', () => {
      document.getElementById('dot-mqtt').className = 'dot on';
      document.getElementById('status-mqtt').textContent = 'mqtt: connected';
    });
    mqttClient.on('offline', () => {
      document.getElementById('dot-mqtt').className = 'dot off';
      document.getElementById('status-mqtt').textContent = 'mqtt: offline';
    });
  } catch (e) {
    document.getElementById('dot-mqtt').className = 'dot off';
    document.getElementById('status-mqtt').textContent = 'mqtt: error';
  }
}

let lastMqttPublish = 0;
function publishTelemetry() {
  if (!mqttClient?.connected) return;
  const now = Date.now();
  if (now - lastMqttPublish < 500) return;
  lastMqttPublish = now;
  mqttClient.publish('driving/player/telemetry', JSON.stringify({
    speed: +speed.toFixed(1),
    position: { x: +carX.toFixed(2), z: +carZ.toFixed(2) },
    score: Math.round(score),
    scenario: currentScenario,
  }));
}

function publishEvent(eventType) {
  if (!mqttClient?.connected) return;
  mqttClient.publish('driving/player/telemetry', JSON.stringify({
    speed: +speed.toFixed(1),
    position: { x: +carX.toFixed(2), z: +carZ.toFixed(2) },
    score: Math.round(score),
    event: eventType,
  }));
}

// ===== ANIMATION LOOP =====
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);

  if (sessionActive) {
    lastSpeed = speed;

    // Acceleration / braking
    braking = false;
    if (keys['KeyW'] || keys['ArrowUp']) {
      speed += 40 * dt; // accelerate
    }
    if (keys['KeyS'] || keys['ArrowDown']) {
      braking = true;
      speed -= 60 * dt; // brake
    }

    // Natural deceleration
    if (!keys['KeyW'] && !keys['ArrowUp']) {
      speed -= 10 * dt;
    }
    speed = Math.max(0, Math.min(130, speed));

    // Steering
    const steerInput = ((keys['KeyA'] || keys['ArrowLeft']) ? 1 : 0) - ((keys['KeyD'] || keys['ArrowRight']) ? 1 : 0);
    const steerSpeed = speed > 5 ? 2.0 : 0.5;
    steerAngle += steerInput * steerSpeed * dt;
    steerAngle *= 0.92; // return to center

    // Update car position
    const speedMs = speed / 3.6; // km/h to m/s
    carAngle += steerAngle * speedMs * dt * 0.15;
    carX += Math.sin(carAngle) * speedMs * dt;
    carZ += Math.cos(carAngle) * speedMs * dt;
    distanceTraveled += speedMs * dt;

    // Update car group
    carGroup.position.set(carX, 0, carZ);
    carGroup.rotation.y = carAngle;

    // Wheel spin
    const wheelSpin = speedMs * dt * 3;
    wheels.forEach(w => w.rotation.x += wheelSpin);

    // Brake / turn signal visuals
    const brakeIntensity = braking ? 1.0 : 0.3;
    tailLightLeft.material.emissiveIntensity = brakeIntensity;
    tailLightRight.material.emissiveIntensity = brakeIntensity;

    const blink = Math.sin(Date.now() * 0.008) > 0;
    turnSignalLMesh.material.emissive.setHex(turnSignalLeft && blink ? 0xfbbf24 : 0x000000);
    turnSignalRMesh.material.emissive.setHex(turnSignalRight && blink ? 0xfbbf24 : 0x000000);

    // HUD indicators
    document.getElementById('ind-left').className = 'indicator' + (turnSignalLeft && blink ? ' active-left' : '');
    document.getElementById('ind-right').className = 'indicator' + (turnSignalRight && blink ? ' active-right' : '');
    document.getElementById('ind-brake').className = 'indicator' + (braking ? ' active-brake' : '');

    // Camera follows car (third person)
    const camDist = 8;
    const camHeight = 4;
    const camTargetX = carX - Math.sin(carAngle) * camDist;
    const camTargetZ = carZ - Math.cos(carAngle) * camDist;
    camera.position.x += (camTargetX - camera.position.x) * 3 * dt;
    camera.position.z += (camTargetZ - camera.position.z) * 3 * dt;
    camera.position.y += (camHeight - camera.position.y) * 3 * dt;
    camera.lookAt(carX, 1, carZ);

    // Scoring
    checkScoring(dt);

    // Auto-summary after long enough drive
    if (distanceTraveled > 800) {
      showSummary();
    }
  }

  // Speedometer
  drawSpeedometer(speed);

  // Sun follows car roughly
  sun.target.position.set(carX, 0, carZ);
  sun.position.set(carX + 30, 50, carZ + 20);

  // MQTT telemetry
  publishTelemetry();

  renderer.render(scene, camera);
}

// ===== RESIZE =====
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Fade instructions
setTimeout(() => {
  const inst = document.getElementById('drive-instructions');
  if (inst) inst.style.opacity = '0';
  setTimeout(() => { if (inst) inst.style.display = 'none'; }, 500);
}, 8000);

// ===== INIT =====
initMQTT();
animate();
</script>
</body>
</html>
